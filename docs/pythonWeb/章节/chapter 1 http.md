# 第一章

## Flask

### 诞生

Flask的诞生源于一个玩笑，在Flask诞生的时候，网上十分流行**微框架**。其作者Armin Ronacher 注意到了这点，并做了一个“虚假”的微框架，包含演示视频、示例代码等等。没想到获得了广泛的关注，于是作者 Armin 真做了一个微框架Flask。

### 简介

Flask是一个用python编写的微框架，其用于实现Web应用程序。微框架并不意味着Web应用程序的代码只放置在一个.py文件中，而是**意味着代码简洁且易于扩展**。

Flask相较于Django框架更加灵活、易用。Flask默认依赖于Werkzeug工具包和jinja2模板引擎（两个外部库），仅仅保留了Web开发的核心功能。如果开发者需要扩展功能，Flask的官网提供了相应的扩展包。

### 特点

Flask如此受到欢迎是因为其具备如下的特点：

- 内置服务器和调试器

  Flask**自带开发服务器**，可以让开发者调试Web应用程序时无需安装其他网络服务。且Flask开发的程序**默认处于调试状态**。

- 使用jinja2模板引擎，

- 极强的定制性，字面意思不做解释

- 基于Unicode编码格式

- 完全兼容WSGI（Web Server Gateway Interface，Web服务器网关接口）

- 无缝衔接单元测试

  是指对于软件中的最小可测试单元进行检查和验证。

## 路由与视图函数

在用户使用浏览器访问网页过程中，浏览器首先会发送一个**请求**到服务器，服务器接收到请求，会将请求转交给`Flask`进行处理。（仅限于基于Flask进行的web编程）

Flask对用户所访问的URL进行**解析**，找到**相应的响应内容**，将其**返回到浏览器**。

**路由**的作用是帮助Flask知晓URL对应的内容在哪儿。

Flask运行的代码是由多个被**装饰器**`app.route` 装饰的**函数**所组成。这个装饰器用于**定义路由**，由此确定URL和python函数之间的映射。

```python
@app.route('/')
def hello():
	return 'hello world'
```

被路由装饰器装饰的函数我们称作：**视图函数**

用于返回URL请求的相应响应内容。



## HTTP

### 请求响应

<u>浏览器向服务器**发送了“请求”**，服务器处理后给浏览器**返回了“响应”**</u>。这样一个简单的流程，其实就是HTTP的核心。

HTTP是一个简单的“请求一响应”协议其性质为**无状态协议**，**对事务处理没有记忆能力**。这意味着每一次交互都是完全独立的。

例如，用户访问了首页与文章列表页，而服务器只知道有用户访问了首页与文章列表页，却无法确定是否是同一个用户访问的。



#### 请求信息

在请求网页的时候，浏览器不单会提交**URL**，还有其他数据：**浏览器的版本**、**语言**、**支持的编码**



#### 响应状态码

“无状态协议”其中所指的无状态意味着两次HTTP交互之间不存在联系。与状态响应的状态无关。

| 状态码  | 信息                     | 解释                         |
| ------- | ------------------------ | ---------------------------- |
| **200** | **OK**                   | 一切正常                     |
| 301     | Moved Permanently        | 重定向                       |
| 400     | Bad Request              | 客户端请求错误               |
| 403     | Forbidden                | 无权限访问                   |
| **404** | **Not Found**            | 找不到页面                   |
| 405     | Method Not Allowed       | 客户端使用了不支持的提交方法 |
| **500** | **Internet Sever Error** | 服务器端出错                 |
| 502     | Bad Gateway              | 代理与服务器之间访问错误     |



## Cookie

HTTP每一次交互都是独立的，无法存储数据，为了解决这个问题进而衍生出了`Cookie`

Cookie 是一种由服务器发送到用户浏览器，并由浏览器存储在用户计算机上的**小型文本文件**。因为Cookie存储容量有限，十分小，仅存储4KB，它通常用于存储用户的**临时信息**、**用户偏好设置**等数据。

Cookie需要浏览器本身支持，具体来说：

- 当用户访问网站时，服务器会在**HTTP的响应包头**添加一个Cookie指令，发送到用户的浏览器。
- 当浏览器接收到这个Cookie指令之后，浏览器存储这个Cookie到本地。
- 在之后的请求中，浏览器会将Cookie添加到**HTTP请求包头**中，将存储的Cookie发送回服务器。
- 服务器通过读取Cookie中的信息来识别用户，并根据存储的数据提供个性化服务。

本地和服务器侧都会存有Cookie。



### Cookie的安全性

- Cookie可以被设置为`HttpOnly`，这意味着JavaScript无法访问Cookie，从而减少了跨站脚本攻击（XSS）的风险。
- 为了提高安全性，Cookie可以**设置过期时间**，或者限制Cookie**仅在`HTTPS`连接中传输**。

### Cookie的隐私问题

- 由于Cookie可以存储在用户的计算机上，它们可能会引发隐私问题，特别是当Cookie用于跨站跟踪时。
- 用户可以通过浏览器设置来控制Cookie的使用，例如，禁用第三方Cookie或定期清除Cookie。





## Session

`Session`与`Cookie`的作用相似，都用于**存储状态数据**。

不同的是，**<u>Session只能在服务器端进行管理</u>**，用户在本地无法对其进行修改，因而安全性较高。Session一般用于存储用户登录状态等对安全性要求较高的信息。

为了保证数据的安全性，Session一般有以下两种存储方式。

1. 使用Cookie记录一个随机生成的`session id`，`session id`用于记录`Session`与用户的映射关系，所有数据存储于服务器端，用户无法修改数据。
2. 所有Session数据都在服务器端加密，然后存储在浏览器的Cookie中。若用户拥有加密算法及密钥，则Session数据可以被用户修改。



Flask默认以第2种种方式存储Session。即所有Session数据**在服务器端加密**，**存储在浏览器的Cookie中**。





`tips`

删除cookie操作

```python
resp.delete_cookie('last_access_time')
```

删除session操作

```python
session.pop('sign_in_time_prev') #删除特定的Session
```







# 扩展补充

### Django

Django是一个开源的**全栈Web框架**，由Python语言编写。提供了许多内置功能和工具，适用于构建大型、复杂的 Web 应用。Django遵循MVC设计模式，即模型（Model）、视图（View）和控制器（Controller）

相较于Flask的微框架，Django提供的功能更为丰富，强大。而Flask的定制性更强，意味着Flask更为灵活、小巧适合中小型的Web开发。

同时也因为Django更为健全，其相较于Flask在Web应用的安全性上十分优秀。但更为健全以及复杂的功能使得Django在多数场景的性能不如Flask。

**Flask：**

- **小巧**、**灵活**，让程序员自己决定定制哪些功能，非常**适用于小型网站**。
- 对于普通的工人来说将毛坯房装修为城市综合体还是很麻烦的，使用Flask来开发大型网站也一样，**开发的难度较大**，代码架构需要自己设计，开发成本取决于开发者的能力和经验。
- **Flask在处理请求时通常比Django更快**，具有更低的延迟和更高的吞吐量。由于Flask本身较为轻量，性能表现相对更优，**适合需要高并发处理的应用场景**
- 需要开发者自行选择合适的安全性扩展和库来加强应用程序的安全性

**Django：**

- 大而全，功能极其强大，是Python web框架的先驱，用户多，第三方库极其丰富。
- 非常适合企业级网站的开发，但是对于小型的微服务来说，总有“杀鸡焉有宰牛刀”的感觉，体量较大，非常臃肿，定制化程度没有Flask高，也没有Flask那么灵活。
- <u>在**处理复杂的数据模型**和**数据库查询**时可能更有效率</u>。Django由于内置了大量功能，**相比Flask在性能上略显不足**。
- 在安全性方面拥有较好的记录，提供了许多内置的安全性功能和工具，同时社区也非常积极地进行漏洞修复



### jinja2

模板在Python的web开发中广泛使用，它能够有效的将**业务逻辑**和**页面逻辑**分开，使代码可读性增强、并且更加容易理解和维护。

`Jinja2` 是一个现代且设计为可嵌入的模板引擎，它支持Python，能够完全支持Unicode。

其**设计思想来源于Django的模板引擎**，并扩展了其语法和一系列强大的功能。其中最显著的一个是增加了**沙箱执行功能**和**可选的自动转义功能**，这对大多应用的安全性来说是非常重要的。

`Jinja2` 被广泛用于Web开发，特别是在Python Web框架中，如Flask和`Django`（`Django`使用的模板引擎是`Jinja2`的一个定制版本）。`Jinja2` 继承自 `Jinja` 模板引擎，并增加了新的功能和改进。

#### 沙箱执行功能

沙箱执行模式，模板的每个部分都在引擎的监督之下执行，模板将会被明确地标记在白名单或者黑名单中，这样对于那些不信任的模板也可以执行。

#### 转义功能

转义功能是指将特殊字符转换成 HTML 转义序列的过程。这样做的目的是为了防止跨站**脚本攻击（XSS）**和确保模板输出的安全性。



### Werkzeug

Werkzeug 是一个用 Python 编写的 WSGI（Web Server Gateway Interface）工具库，它为 Python Web 应用程序的开发提供了丰富的功能和灵活的工具。



### WSGI

WSGI（Web Server Gateway Interface）是一个**Web服务器**和**Web应用程序或框架**之间的**接口标准**，用于Python应用程序。WSGI定义了一种方式，使得Web服务器可以与遵循WSGI标准的任何Python Web应用程序或框架进行通信。这种接口**使得开发者可以轻松地更换Web服务器或Web框架**，而**不需要修改应用程序代码**。





**WSGI（Web Server Gateway Interface）**：

- WSGI 是一个Python语言的Web服务器网关接口标准，定义了Web服务器和Web应用程序或框架之间的通信协议。
- 它规定了Web服务器如何将请求信息传递给Python应用程序，以及Python应用程序如何将响应信息返回给Web服务器。
- WSGI是一个抽象的接口定义，它本身并不是一个具体的实现，而是一个规范，任何遵循这个规范的Web服务器和Web框架都可以互相配合工作。

**Werkzeug**：

- Werkzeug 是一个Python库，提供了WSGI工具和实用程序，包括一个WSGI服务器、一个强大的WSGI实用程序库和一套用于调试的WSGI中间件。
- Werkzeug 实现了WSGI规范，提供了WSGI环境和响应对象，以及用于创建和处理WSGI应用程序的工具。
- Werkzeug 可以作为一个独立的WSGI工具库使用，也可以作为Web框架Flask的一部分，Flask内部大量使用了Werkzeug提供的功能。

**关系**：

- Werkzeug 实现了 WSGI 规范中定义的接口和功能，使得它能够与任何遵循WSGI标准的Web服务器或Web框架进行交互。
- 通过Werkzeug，开发者可以创建WSGI应用程序，处理HTTP请求和响应，而不需要直接处理底层的WSGI协议细节。
- Werkzeug 提供的WSGI服务器可以用于开发和测试阶段，而生产环境通常会使用更强大的WSGI服务器，如Gunicorn、uWSGI等。



### XSS-跨站脚本攻击

XSS（Cross-Site Scripting，跨站脚本攻击）是一种常见的网络安全漏洞，它允许攻击者在用户的浏览器上执行恶意脚本。XSS 攻击通常发生在攻击者将恶意脚本注入到其他用户会访问的网页中，这些脚本可以盗取用户数据、会话令牌、修改网页内容，或者重定向用户到恶意网站。

XSS 攻击可以分为以下三种类型：

1. **存储型 XSS（Persistent XSS）**：
   - 攻击者的脚本被存储在目标服务器上，通常是数据库中。
   - 当其他用户访问受污染的页面时，恶意脚本作为正常内容被发送到用户的浏览器中执行。
   - 例如，攻击者在论坛帖子、评论区或用户个人资料中注入脚本。
2. **反射型 XSS（Non-Persistent XSS）**：
   - 攻击者的脚本不是存储在服务器上，而是通过 URL 参数或其他方式直接传递给用户的浏览器。
   - 当用户点击一个包含恶意脚本的链接时，脚本作为响应的一部分被发送到用户的浏览器中执行。
   - 例如，攻击者诱使用户点击一个链接，该链接的 URL 中包含了恶意脚本。
3. **DOM 型 XSS（DOM-based XSS）**：
   - 这种类型的 XSS 攻击发生在客户端，恶意脚本通过修改 Document Object Model（DOM）来执行。
   - 攻击者利用网站本身的 DOM 处理逻辑缺陷，通过修改页面的 DOM 或者操作浏览器的 API 来执行恶意脚本。
   - 例如，攻击者通过修改 JavaScript 代码来改变页面上的数据流，从而执行恶意代码。
