## Yarn-资源调度

`yarn`结构是`Hadoop 2.x`版本中的一个关键特性，取代了旧版本中的`JobTracker`和`TaskTracker`。

YARN的设计目标是：

- 使`Hadoop`能够处理更广泛的**工作负载**，包括**批处理**、**流处理**、**交互式查询**、以及其他类型的工作负载；
- 多计算框架之间利用率低(多个计算框架之间的资源无法实现公用，高效率使用)；
- 且早期的MRv1仅仅支持MR计算框架且容易发生单点故障。

三类计算框架：

- `MR`：离线计算框架，离线处理
- `Storm`：实时计算框架，实时计算
- `Spark`：内存计算框架，迭代计算

`YARN` 仅仅**负责分配资源**，调用资源至于资源用于作业怎么运行，其不用关心。其为上层应用提供了统一的资源管理和调度，它为引入集群在**利用率**、**资源统一管理**和**数据共享**有很大的作用。

我们把Client向yarn发送执行的应用程序称作作业（`job`）也称作任务

下图是yarn的架构

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/9c54901d916d98893493ec527aeba791.png)

### word count







### 架构

#### `ResourceManager`（RM）

RM进行统筹规划。可以把`RM`看作`NN`，它是`yarn`上的主节点。

RM是一个全局的资源管理器，管理整个集群的计算资源。RM**管理和分配**整个YARN集群的计算资源，即**内存**、**CPU**和**磁盘空间**。并且**通过其他组件获取每个节点的资源使用情况**，根据资源使用情况做出**调度决策**。

RM与`NodeManager`通信（以此来了解每一个节点的资源使用情况）其管理`NodeManager` ，**接收来自`NodeManager` 的资源汇报信息**，并向`NodeManager`**下达管理指令**。由`NodeManager`分配Container给各个应用程序的AM（RM为每个应用程序分配一个唯一的**Application ID**。并管理AM的生命周期，在它运行失败时重新启动它，可以理解为AM帮助RM获取作业的情况）。调度资源确保Container的资源需求（如内存和CPU）**得到尽可能100%使用**。

RM同样定期接收来自NM的**心跳信号**，以跟踪节点的健康状况和资源使用情况。RM也接收来自AM的心跳信号，以监控应用程序的状态。

如果RM失败，YARN提供了**自动故障转移机制**，以确保集群的高可用性。RM的状态信息被**持久化存储**，以便在故障转移时恢复状态。



#### `NodeManager`（NM）

资源管理，RM下达管理指令由**NM执行指令**，对所在节点的资源进行管理和分配。

`NodeManager（NM）`是 `YARN`架构中的一个核心组件，它在`Hadoop`集群中的每个计算节点上运行，<u>**负责管理该节点上的资源和任务容器**</u>（Containers）。NM负责在节点级别**实施RM的资源分配决策**。当RM决定在某个节点上为特定作业分配资源时，它会通知该节点的NM启动一个或多个容器。NM管理着容器的生命周期，包括**启动容器**、**监控容器**资源使用情况、**处理容器**的停止和清理工作。NM监控容器的实际资源使用情况，确保容器**使用不超过申请的资源量，并汇报给RM**。

也就是管理container的情况，同时按照RM的指令分配。从资源的角度。AM则从作业的角度。二者的视角帮助RM对整个资源、作业协调管理。



#### `ApplicationMaster`（AM）

AM用于作业管理。主要负责**执行作业的流程**和**调度作业**的任务

`ApplicationMaster`是大数据计算框架中的核心组件，负责向`ResourceManager`申请任务所需要的资源，是`RM`的**作业管理组件**。并在作业的期间，由`AM`获取每个作业的状况（**周期性汇报给RM**）。其帮助存在着依赖关系的作业之间维持依赖关系，还可以帮助失败的任务，重新换一个节点启动。实际上`AM`是**作业自己提供的组件**。AM本身就是运行在`container`中的，<u>当AM向RM申请资源，RM会为AM分配一个Container并让其在这个Container中运行。</u>

- **资源协商**：与RM进行协商，获取执行任务所需的资源，这些资源以Container的形式表示。
- **任务分配**：将获得的资源进一步分配给内部的任务，如`MapReduce`作业中的Map任务和Reduce任务。
- **任务监控**：与`NodeManager`（NM）通信，启动和停止任务，并监控所有任务的运行状态。
- **容错处理**：如果任务运行失败，AM会重新为任务申请资源以重启任务。
- **状态报告**：AM向RM报告应用程序的进度和状态，以便于客户端可以查询应用程序的执行情况。



#### `Container`

Container 是 Yarn 中的**资源抽象**，它**封装了某个节点上的多维度资源**，包括内存、CPU、磁盘、网络等。可以看作是任务执行的一个小环境。为了使得yarn的资源管理达到更为细小的粒度，`container`是一种对于资源的划分，所以`container`是资源分配和调度的**最小单位**。

yarn

### 调度策略

相比较yarn的架构当中的组件，更为重要的是yarn的调度策略。在分布式系统中，调度器大多都是**多用户调度器**。

#### 容量调度器

容量调度器基于“**队列**”的概念来实现调度策略。管理员会定义好**队列的数量**以及每个**队列的资源量（也就是容量，资源最低保证和使用上限）**，只需要保证总体的最小资源量为100%就行。其<u>从逻辑上定义了一个资源范围</u>，这个范围叫做队列的容量。作业会被分配到不同的队列上排队，保证同一时间有多个作业运行，而每一个队列当中又按照`FIFO`进行调度作业。

支持<u>队列的层次结构</u>，**允许在组织的子队列之间共享资源**。在一个队列中运行的`Job`不允许使用超过范围的资源，也就是不能**超过队列的容量**，否则该作业会被**立刻杀死**。但如果存在别的**空闲队列**，则可以**临时共享给其他需要资源的队列（共享资源上限是获得资源队列所配置的资源使用上限）**。

容量调度器是一种**多租户调度器**，它允许**多个组织共享**整个集群资源，同时会**防止**单个应用程序、用户或队列**独占**集群资源，确保每个组织都能获得一定的资源容量保证。容量调度器当中每个队列都有严格的访问控制列表（`ACL`，access control list），以确保只有授权的用户可以向队列提交应用程序（**安全性**）。且可以在运行时修改其配置，是任何配置。

队列资源分配，按照深度优先算法，**优先选择资源占用率最低的队列开始分配资源**。作业资源分配，则默认按照作业的**优先级**和**提交时间顺序**分配资源。容量资源分配按照容量优先级，优先级相同按照**数据本地性原则**。



#### 公平调度器

公平调度器也是按照**队列**概念实现了资源调度，其目标是公平地在所有运行的作业之间分配集群资源，确保所有作业都能获得合理的资源份额（**同队列所有任务共享资源**，时间尺度上获取公平的资源）。所以与容量调度器有很大的不同，管理员还需要定义好最多运行的`job`数量。公平调度器不仅可以定义一个资源范围，也可以通过定义队列的权重。从理论上来说公平调度器是想**让所有job立即运行不必等待**，而容量调度器**只是想运行和队列数量相同的job**。

分配队列的时候公平调度器按照**缺额分配**，优先为**缺额大的作业分配作业**。缺额的计算为
$$
缺额 = 公平份额 - 实际份额 \\ (队列权重/所有队列权重总和)*集群总资源 - (队列权重/所有活跃队列权重总和)*集群总资源
$$
当缺额为正，说明着队列还没有获得足够的资源，因此调度器会尝试分配更多资源（应该理解为这个队列的资源没有被充分调用）。

一般最少为零，说明队列已经获得了公平的份额。



##### Fair策略

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/04f5ea99818c612f70d71f13f0396f90.png)



##### DRF策略

上述说的资源都是单一标准，例如只考虑内存(Yarn默认情况)。但很多时候我们资源有很多种，例如内存、CPU、网络带宽等，这样就很难衡量两个应用应该分配的资源比例。

所以在Yarn中，我们使用DRF来决定如何调度：

DRF(Dominant Resource Fairness)主导资源公平调度算法，是一种通用的多资源最大-最小公平分配策略(Max-Min Fairness Strategy),核心思想是在多环境下一个用户的资源分配应该由用户的主导份额资源决定。用户所有份额中的最大值称为该用户的主导份额，与主导份额相对应的资源称为主导资源。

假设集群一共有100 CPU和10T 内存，而应用A需要(2 CPU, 300GB)，应用B需要(6 CPU，100GB)。 则两个应用分别需要A(2%CPU, 3%内存)和B(6%CPU, 1%内存)的资源，这就意味着A是内存主导的, B是 CPU主导的。

#### 资源分配算法

##### 队列资源分配

先根据队列数分，再根据需求和多余量，进行整合与重新分配

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/dfae1fddee9dc18414dc97b3675e1554.png)

##### 作业资源分配

也同样先根据总数分，再根据需求和多余量，进行整合与重新分配直到没有空闲资源，或者`job`的资源被分配完全。

![请添加图片描述](https://i-blog.csdnimg.cn/blog_migrate/73a7ea41771564dc96be99bc2d47b3b6.png)

### 自动故障转移



