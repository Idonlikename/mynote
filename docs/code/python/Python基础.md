#  Python

## 基础知识

Python是**弱定义编程语言**(**解释类型**)。但关于python是否是一**弱类型语言**具备一些争议，

**脚本语言**，他是**<u>编译与运行同时进行，边译边跑</u>**，大多数python异于C语言的原因正是此。**<u>速度远慢于C和C++</u>**

<u>Python2不可以用汉字做变量名</u>，python3可以，但是python不可以用纯数字

<u>Python3中字符串是Unicode (utf-8)编码，支持中文做标识符</u>

<u>Python2中是ASCII编码，需要更改字符集才能正常支持中文</u>，所以在.py文件中会看到，所以二者的str类型是不同的。

### 特性

Python中大多数**<u>所取的区间都是左闭右开的区间</u>**，只有才用特殊方法才能达到闭区间的方法

一些特殊性：**int类型不能像列表那样遍历**，但是str可以，**str**虽然可以遍历，但**无法直接修改某个char的值**要用**replace**

可以用`a,b=b,a`的方法实现**a,b的值的互换**

Python中的**关键字是非函数的自定部分（if,else,for）**（函数不是关键字）

输出print(“%类型”%变量名)**输出多字符串时变量名**需用（）包含如：**`print(“%s%s”%(a,b))`**

print在做输出时，参数需要用"`,`''隔开（**空格不行**），print只会输出`""`内部的文本。在`""`只认参数，其他输出方式参考**format**和**f-string**

输入input(“”)（input的**内容默认为字符串**类型）

### 类型

#### 基础类型

int-整型 

float-浮点

bool-布尔值

complex(各种类型组合)  

##### 以int为例子的类型转换

int的强制类型转化：**class int(x, base=10)**

**参数**
 `x` -- 字符串或数字。

`base` -- 进制数，默认十进制。

**返回值**
 返回整型数据。

**int()** **方法的实例：**

```python
int()        # 不传入参数时，得到结果0
0
int(3)   # 输入整数的时候，默认10进制
3
int(3.6)   #  浮点数向下取值
3
int('12',16)    # 如果是带参数base的话，12要以字符串的形式进行输入，12 为 16进制
18
int('0xa',16)   #  16进制 转10进制
10 
int('10',8)   # 8进制转10进制
8
```

 可以通过Int(),float(),str(),chr()……**强制改变字符的类型**，但**不会改变原先变量**的类型，会**创建一个新对象**。

bin()

#### 可迭代类型

list-列表  

tuple-元组  

dictionary-字典  

set-集合

  

None(None是 None Type中唯一的值)



**可变类型：意味着你可以修改它的值**

List（列表）、Dictionary（字典）、Set（集合）

可变类型的对象如果指向一个数据对象，那意味着他们指向同一个地址，其中一个对象会随着另一个对象的改变而改变

 

**不可变类型：不能修改值**

Number（数字float  int）、String（字符串）、Tuple（元组）、Bool(布尔值)



### 变量的定义规则

作为变量名标识符是由字母、数字和下划线(_)构成的字符序列

标识符必须以字母或下划线(_)开头，不能以数字开头

标识符不能是关键字



### 运算符号

这里仅举python中特殊的例子。

其余对标C语言的加减乘除以及关系运算符号

| 符号 | 含义 |
| ---- | ---- |
| //   | 整除 |
| **   | 幂次 |
| and  | &&   |
| or   | \|\| |
| not  | !    |
| %    | mod  |

提及一个比较小众的

`pow(x,p,y)`意味着x^p^ mod y可以直接计算

#### 短路

判断时因为不符合唯一特殊输出的情况而中途停止的情况

```
print(num or num) / print(num and num)
```

在判断的时候，注意or/and的或与门。0为0，其他均看作1

```python
Print(0 or 3)
>3
Print(2 or 4)
>2
Print(0 and 3)
>0
Print(5 and 4)
>4
```

因为`and`会在前后件都为1的时候输出1，而前件为0的情况会让直接停止判断输出0。其他情况均输出后面的值

`or`同理，在都为0的时候才会输出1，而前件为非0时会直接停止判断输出前件。前件为0则输出后件。

 

Python 中判断对错的输出为 Ture和False(**bool**),可以用in（成员运算符）的方法来判断某个值是否在一个序列（列表，元组，字符串）之内

```python
A='156487'

B='1'in A

print(B)

>True
```

 

#### **身份运算符**以及内存位置

**is  is not**

身份运算符所判断的是两个变量的内存是不是相同。可以用 `id()`来查看变量的内存位置。

```python
A=5

B=5

Print(A is B) 
```

输出`True`

说明指向的内存相同，也就是ID相同可以用**`id()`**来看A,B的内存位置。

**<u>在int，string，turple 三种变量类型的情况下地址相同</u>**

```python
A={1，3，2}

B={1，2，3}

Print(A==B) 
#输出True

Print(A is B)
#输出False，说明虽然值相同，但指向内存不同。其他如列表，字典，集合内存指向不同。
```

### 深浅拷贝

**浅拷贝**和**深拷贝**，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象共享一块内存

但深拷贝会创造一个一模一样的对象，新旧对象不共享内存。 

## 函数

### 内码字符转换

`ord()`转成内码

`chr()`转回字符

### 最大值最小值

`max()`和`min()`

`max()`和`min()`是Python内置函数，用于求取一个**可迭代对象**中的最大值和最小值。

`()`内需要传入一个**可迭代对象**作为参数

其中max()返回可迭代对象中数值最大的元素，而min()则返回可迭代对象中数值最小的元素。

```python 
num = [1,4,5,6,7,9,0]
max = max(num)
min = min(num)
print(max,min)
>9 0
```

这两个函数可以接受任何可迭代对象作为参数，包括列表、元组、集合等等。在使用时，需要注意**参数类型必须是一致的**。

也可以用于求多个数字间最大值和最小值

**count(x,start,end)**(x为要寻找的字符)，count在计数字符串内的元素时可以进行范围的指定，但是在列表中是不可以指定范围的

 

**str.center(number,“x”)**#number代表输出新的字符串的占位总宽度。而x表示作为填充的部分（有且仅能为字符，所以外部一定需要引号），x默认为空格。输出为str的内容居中，而x在左右进行填充直到满足number占位的要求。不会对原先的字符串做出更改，会返回一个新字符串

 

**.replace()**： 

replace函数可以用于替换字符串中的指定子字符串

格式：

处理项目.replace(被替换元素，替换元素，替换次数)

替换次数没有的话默认是全部替换的。

 

很多语言字符串使用string表示，python里面使用str表示

字符串查找类，find，index，islower（判断小写）

 

**find()**

**str.find(str, beg=0, end=len(string))**

包含子字符串则返回开始的索引值，否则返回-1。(仅对字符串有效)

 

**Index()**:跟find的区别： 

① index可以适用于列表。

② 如果找不到，会引发异常会返回none（会报错）

index语法格式与find一致。

find只适用于字符串，而index和count还可以用于列表.

 

**rfind****，lfind**：从左开始查或者从右开始查

判断类的str函数

此类函数的特点是一般都用is开头，比如islower

 

**isalpha**：判断是否是字母，需要注意的是两点：

 

此类函数默认的前提是字符串至少包含一个字符，如果没有，同样返回False

 

汉字被认为是alpha，所以，此函数不能作为区分英语字母还是汉字的标识，区分中英文请使用Unicode码

 

isdigit , isnumeric, isdecimal三个判断数字的函数

\- 此类函数不建议使用，在后期爬虫中，判断是否是数字建议采用正则表达式的方式

isinstance(x,type)#判断子类x是否归属于父类类型

 

内容判断函数

**startswith/endswith****（suffix,strat,end）**:是否以xxx开头或者结尾检测某个字符串是否以某个字串开头，常用三个参数返回T/F：

**suffix**：被检查的字符串，必须有

**start**：检查范围的开始范围

**end**：检查范围的结束范围

**islower/isupper**：判断字符串是否是大写或者小写

x=3
b=[ 1 , -1] [x > 5 ]
a=1 if x>5 **else** **b



**print(a)**

这串代码，分为两个部分解析：

**b=[1,-1] [x>5]**：如果x>5则b=1否则b=-1，一种选择代码。

a=[值1，值2] [值1的条件]

第二段三目运算，if x>5 a=1 else a=b简写：

A=1 if x>5 else b

A=值1 if 值1的条件 else 值2（可以反复写）

三目和另一种特殊方法

**.map()：**

它的作用是**将一个函数映射到一个可迭代对象**（比如列表、元组等）的所有元素上，返回一个新的迭代器对象。其基本语法格式如下：

**`map(function, iterable)`**

`function`：是一个函数，可以对后续迭代项内的值逐个进行操作

`iterable`： 是一个可迭代对象，可以是列表、元组、字典、集合或字符串等，... 表示可以有多个这样的参数。（取出迭代对象中的元素用function处理，将得到的结果返回一个新的迭代对象）

 

`list1 = list(map(int ,input().split()))`#读入一行由空格分隔的整数，将其存入list1列表中

map() 函数会根据 function 的要求，对iterable 中的每个元素进行计算，返回由函数计算出来的新数据所组成的新迭代对象，其中每个元素都是计算后的结果。（所以对于判断类型的会返回True和False，需要靠filter来过滤）

举个例子：假设我们有一个列表 a = [1, 2, 3, 4, 5]，现在需要将其中的每个元素都加上 1，可以使用 map() 函数来实现：

```python 
a = [1, 2, 3, 4, 5]

b = list(map(lambda x: x+1, a))

print(b)
>[2, 3, 4, 5, 6]
```

在这个例子中，我们首先定义了一个匿名函数 lambda x: x+1，该函数的作用是将传入的参数加 1，然后  通过 map() 函数将这个函数应用到列表 a 中的每个元素上，并将结果存放在列表 b 中。最后，我们使用 list() 将返回的迭代器对象转换为列表类型并打印输出。

```python
a = [“1”,“2”,“3”,“4”]

b = list(map(int, a))

print(b)

>[1,2,3,4]
```

需要注意的是，map() 函数返回的是一个迭代器对象，如果需要得到列表类型的结果，则需要list()将其转换为列表类型。

```python
lst1 = [1, 2, 3]

lst2 = [4, 5, 6]

result = list(map(lambda x, y: x + y, lst1, lst2))

print(result)  
>[5, 7, 9]
```



`Filter():`

filter过滤函数，和map()类似，也接收一个函数和一个序列，但是和map()不同的是，filter()对于引入的判断函数会依次作用于每个元素，判断函数会返回序列中True的数据（map对于判断函数只会返回Ture和False），处理类型的函数会直接对序列进行处理（可以理解处理完的数据本身还是True的）。接收序列，返回符合函数的序列，需要用序列的类型方法改变序列的类型。

Filter(function, sequential)



`reduce:`

格式采用：**`reduce (function, sequence initial])`**

其中function因为是调用函数所以不需要带上括号。

把一个函数作用在一个序列上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算:

reduce(f, [x1,x2,x3,x4,x5]) = f(f(f(x1,x2),x3),x4) ---作用形象表达

python3中不是内置函数，需要导入：**`from functools import reduce`**

```python
from functools import reduce
def multi(x, y):

  return x*y

def add(x, y):

  return x + y

print(reduce(multi, range(1,4)))    # 累乘

print(reduce(add, [1,2,3,4,5]))    # 累加

>>6 15
```

 



 

**.split()**

在Python中，split()函数是字符串类型的内置函数，用于将一个字符串分割成多个子字符串，并将结果存储在一个列表中(返回一个列表)。

按照空格分割字符串，默认情况下，函数会按照空格来分割字符串，返回值为分割后的列表。例如：

```python
str = "Hello World!"

print(str.split())

>>['Hello', 'World!']
```

按照指定的分隔符分割字符串，函数可以根据用户指定的分隔符来分割字符串，返回值也是分割后的列表。例如：

```python
str = "apple,banana,orange"

print(str.split(','))

>>['apple', 'banana', 'orange']
```

按照指定的分隔符分割字符串，并限制分割次数，如果希望只分割一部分字符串，则可以使用可选参数maxsplit来指定最大分割次数。例如：

```python
str = "apple,banana,orange,pear"

print(str.split(',', 2))

>['apple', 'banana', 'orange,pear']
```

 

按照换行符分割字符串，如果需要按照行来分割字符串，则可以使用换行符（\n）作为分隔符。例如：

```python
str = "Hello\nWorld!\nWelcome to Python!"

print(str.split('\n'))

>['Hello', 'World!', 'Welcome to Python!']
```

 

总结：以上就是 python 中 split() 函数的几种用法，通过不同的分隔符和参数，可以实现不同的字符串分割操作。



**进制转换**

```python
a=int(input(""))
print("输入的十进制数: %d"%a)
b=bin(a)
c=oct(a)
d=hex(a)
print("二进制: {}八进制: {}十六进制: {}".format(b,c,d))
```

bin()#十进制转化为二进制%b

oct()#十进制转化为八进制%o

hex()#十进制转化为十六进制%x

以上进制转化返回的值都是字符串，而且字符中会在前面带着进制的前缀0b,0o,0x（在python要声明一组数是别的进制需要带上这些前缀）0需要利用切片进行处理，从别的进制转为十进制，也需要原来的进制数为字符串。别的进制输出默认输出十进制数

 



.rfind()#作用是找到（）内字符最后出现的位置，无则返回-1

 

round(x,n)

X为要四舍五入的值，n为要保留的小数点位数。没有n默认保留整数。



### 字符串函数

**str.function()**

| 函数               | 作用                 |
| ------------------ | -------------------- |
| .islower()         | 判断是否小写         |
| .isupper()         | 判断是否大写         |
| .capitalize()      | 首字母大写，其余小写 |
| .swapcase()        | 大小写互换           |
| .isalpha()         | 判断是否为字母       |
| .isdigit()         | 判断是否为数字       |
| .isalnum()         | 是否全为字母或数字   |
| .startswith('str') | 是否以'str'开头      |
| .endwith('str')    | 是否以'str'结尾      |
|                    |                      |





### 范围

**range(start,end,step)**#  range可以从start所在位置开始取一直取到end-1的位置，他是由，做分隔符号的，与切片操作中的：做分隔符号要区分开

```python
for i in range(1,10,2):
	print(i,end=" ")
1 3 5 7 9
```



 



 

## 位运算：二进制运算

逻辑运算符: and or not 

一个字符占八位，所以二进制码为0000 0000 **第一位是标志位**，**1为负值，0为正值**



在计算机中，计算机只有加法器，所以需要减法转换为加法计算。



原码：八位二进制数。**对于正数而言原码，反码，补码相同**

反码：除了标志位，全位取反

补码：在反码的基础上+1



具体操作：补码＋补码，通过得到答案的补码，由补码转为原码（补码-1得到反码，反码取反得到原码）。

对于能转换为正数相加的情况，得到的补码答案即为原码

其中超过八位的部分，直接去除，但要注意是否会超出计算范围。



&与运算  |或运算  ^异或运算  ~反码 

```python
a = 2  # 0000 0010 第一位是判断正负值的
b = 3  # 0000 0011
print(a & b)  # 0010
print(a | b)  # 0011
print(a ^ b)  # 0001
print(~a)  # 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 。~x 类似于 -x-1
```

与运算就是每位与门计算（有0为0）

或运算就是每位或门计算（有1为1）

异或运算就是⊕（“异或”运算符）（不同取1相同取0）

 

<<左位移，>>右位移，前件为处理的二进制数，后件为位移数

```python
print(2<<2)  # 0010左移两位成1000得出8
```

快速计算就是，原本2^(原先+后件）

 

计算的优先级：计算>比较>逻辑>赋值

### 进制转化 

```python
a=int(input(""))
print("输入的十进制数: %d"%a)
b=bin(a)
c=oct(a)
d=hex(a)
print("二进制: {}八进制: {}十六进制: {}".format(b,c,d))
```

`bin()` #十进制转化为二进制 格式采用`%b`

`oct()` #十进制转化为八进制 格式采用`%o`

`hex()` #十进制转化为十六进制 格式采用`%x`

以上进制转化**返回的值都是<u>字符串</u>**，而且字符中会在前面带着**进制的前缀**0b,0o,0x（另外在python中要**直接**声明一组数是别的进制需要带上这些前缀）需要利用切片进行处理。

同理：从别的进制**转为十进制**，也需要原来的进制数为字符串。别的进制输出默认输出十进制数

`int.bit_length()`可以返回整数int转为二进制的位数。

## 条件语句

### If

If 语句：

  If 条件1

​    语句1

  Elif 条件2:

   语句2

  Else

​    语句3

Python中if语句if后无需跟上括号和中括号，只要空一格将条件打在if之后补上“：“。且<u>条件执行的语句只需要比if条件语句段落前空几行，就可以表明在此条件语句下运行</u>。

Elif表明其他情况+有条件（末尾也需要添加”:”）

else则变为其他情况。（也要“:“,也可以用于for循环结束时）

区别：在循环以及if语句中python**无需**像C语言一样有条件小括号和执行的大括号**（）{}**，但是需要执行语句段落开始比if和循环语句置后几个单位。且循环**条件语句和if语句**后面**需要添加‘：’** 

`break` 跳出循环，`continue`跳过当前循环

###  三目

个人认为在python中是否重要的一个写法，帮助减少行数，增加代码的易读性（在熟练之后）

```python
eg: m = a if a>b else b
```

格式可以归为：

```python
result_1 if conditon else result_2
```



### Match

```python 
match status:
        case 400:
            return 'Bad request'
        case 401:
            return 'Unauthorized'
        case 403:
            return 'Forbidden'
        case 404:
            return 'Not found'
        case _:
            return 'Unknown status code'
```

语句格式，类似于C语言，**区别在于不会成功后全输出**    ==仅支持3.10以上版本==

 

Python 语言的循环结构包括两种：

遍历循环和无限循环。遍历循环使用保留字 for，无限循环使用保留字 while。

 

## python中的保留字

False, None, True, and, as, assert, async, await, break, class, continue, def, del, elif, else, except, finally, for, from, global, if, import, in, is, lambda, nonlocal, not, or, pass, raise, return, try, while, with, yield



差距在于能不能字典中。判断类型是都可以，处理类型是不能字典中



## 格式化输出

一些格式化输出参数：

`Print(a,end=””)` #python**输出末尾默认换行**，可以用end=“ “用” “内的字符代**替换行输出**

`print(a,b,sep=”-”)`# `sep`为**分割符号**，python和其本身默认是空格，可以用sep改变a,b之间的分割符号，此处用的是`-`

### format

在 Python 中，`format()` 是一个用于格式化字符串的内置函数，它支持多种格式化输出，包括：

具体格式为：  `"{}string{}string".format(data1,data2)`   将data1、2按顺序插入。

按顺序输出：可以在`{}`填入<u>由0开始的下标</u>，填入**format**内对应位置的数据，会将第一个插入到0所在的位置



字符串：使用 {} 占位符将字符串插入到指定位置。

整数或浮点数：可以指定显示位数、小数点后的位数等



**常见的格式**如 ：

1.`{:.2f}` 表示**保留两位小数**。

2.`{:,.2f}`多一个逗号的作用是三位取，做数字的进制的标准逗号 （三位来一个，银行的标准取法）

布尔值：可以使用 {} 占位符来表示 `True` 或 `False`。

 

下面是一些常用的格式化方法：（：指定输出格式，后续表明格式类型）

{}：用于替换字符串型变量。

{:d}：用于替换整型变量。

{:f}：用于替换浮点型变量。

{:s}：用于替换字符串类型变量。 #以上规律用`':'`替代`'%'`

{:<n}：用于左（右边边加空格）对齐，其中 n 为占位符宽度。

{:^n}：用于居中对齐，其中 n 为占位符宽度。

{:>n}：用于右(左边加空格)对齐，其中 n 为占位符宽度。

{:e}:表示科学计数法

在:后添加str，可以str*n

 

Tips: **尖口方向为对齐方向，开口朝向加空格**，在居中对齐时如果n为偶数内容为1，则会**优先左边的空格**多

列表、元组、字典等数据结构：可以通过索引或键名来获取其中的元素，并进行==格式化输出==。且需要在可迭代对象前添加**`*`**使其**展开**，可以在{}中填入相应的索引，否则则默认从0~n（有几个{}则输出几个值）；**字典需要加**，且要在**{}内加入键名**。

如果{}内填入了**数字**，其中数字表示参数在format()中参数列表中的**下标** 

### f-string

一种简便的格式化输出：**`pirnt(f’a={a}’)`**这样也可以做到格式化输出：`a=参数a的值（）`

与format不同的是，在输出可迭代对象的时候不需要加*可以直接输出列表：

​           `print(f’list= {list} ’)`

要做到对齐时  格式{:>n}需要将输出的参数放在冒号之前:

​           `print(f’{a:>n}’)`

f-string还可以对输出的迭代对象进行处理：

​           `list = [1,2,3,4,5]`

​           `print(f’list2={[f”{x**2:2e}”for x in list ]}’)`

`“ ”`和`‘‘`没有什么实际的差别，一般同时出现是为了**区别**作用，以**防止冲突**。比如此处代码。

**<u>f-string的输出类型一定是str</u>**

 

其他list展开方法：

使用join函数格式：

`“ ”.join(list)`  “ ”内的内容决定了各个元素之间的间隔是用什么字符，join**不会改变原来的的项目**，但是会**返回一个新的字符串**。

`join()`同样适用于方法适用于在字符串之间插入分隔符的情况，可以用于**任何可迭代对象**（如列表、元组、集合等）要保证其中的内容仍为**str类型**



 



 

## Def

`def`格式

```python
def  函数名称

  #函数体

  #return返回值
```

在Python中，当**参数是可变对象**（如列表、字典、集合等）时，会出现这种**参数会随着def自建函数内部进行的操作而发生变化**。需要注意的是，如果参数是**不可变对象**（如数字、字符串、元组等），则函数**无法修改原始对象**，也就不存在参数随之改变的情况。在函数**内部声明的变量只在函数内部有效**，不会改变函数外部已经定义的同名变量的值。因此，即使在自建函数中声明了同名的列表，也不会影响外部列表的值。

需要注意的是，如果**<u>在函数内部对于可变类型的参数进行重新赋值（即将其指向一个新的对象），并不会改变原来的可变类型对象</u>**，此时则需要在**声明赋值前**先使用`global`关键字**声明全局变量**，否则电脑认为是函数内部的赋值了一个同名的局部变量，而不会影响到函数外部的同名变量。（**重新赋值指的是重新在函数内给外部的可变类型参数赋值**）



形参和实参的赋值规则：**优先关键字（同名）参数**，再是位置参数

 

```python
def  num(a,b):
    shang=a//b
    yushu=a-shang*b
    return shang,yushu
print(num(9,4))
```

结果为（2，1）

 

### 缺省参数(k)：

```python 
#缺省参数，缺少一个参数值，缺少的值会按照默认的值输出，但是默认的缺省参数必须在最后一位，否则就会按照位置参数上的来
def num(a,b=35):
    print("Name:",a)
    print("Age:",b)
d=10
c=15
num(d)
num(d,c)#c也可以直接输入数字
num(a='which')
num(a='which',b=6)
```

有默认值的话没有实参则输出默认值，有的话就会输出实参计算的结果

 

### 不定长参数：

有时可能**<u>需要一个函数处理比当初声明时更多的参数</u>**。这些参数称之为不定长参数，**声明时不命名**

加了星号(*)的变量args会存放所有未命名的变量参数，`args`为**元组**；而加了(**)的变量`kwrgs`会存放==命名参数==

即形如**`key=value`**的参数，`kwargs`为==字典==

一个(*)为位置参数，两个(**)为关键字参数（二者都可以接受任意数量的位置参数/关键字参数）（前者可认为是元组，后者可认为是字典）二者都是可变数量的参数

 

形参没有加*也可以被认为是元组，如果函数内使用时使用了*则会将列表解包，将其中的元素一个个取出来

 

如果在用自建函数的时候，可迭代项实参前面不加*/**就会被当作单一的元素。

 

加上✳/✳✳会进行解包操作：一个✳用于将一个可迭代对象（如列表、元组，包括字典，会呈现key和value同作为元素的形式）解包成位置参数（也就是一个迭代项目拆成多个参数）。**用于将字典解包成关键字参数（xxx=xxx的形式）。

Tips:将*的项，看作多个项目，**的项目，看作多个xxx=xxx的项目。

 

定义自定义函数的时候参数必须遵循的顺序为：

**一般参数>关键字参数≥不定参数>关键字参数** 

a      a=10    **a *a    a=10

如果，关键字参数和位置参数对调位置也可以正常定义（但其他格式不会正常定义），不特别声明的话，形参只会使用默认参数的默认值。

 

递归函数：递归函数通过自建函数来反复引用从而达到某种目的

```python 
def factorial(n):

  if n == 0:

​    return 1

  else:

​    return n * factorial(n - 1)
```

此处利用递归函数计算阶乘（自建函数，反复引用）

 

引用传参：参数是引用类型的参数，如：列表，元组，字典。

在这类参数如果取用相等，原来的参数进行了修改，会影响到后一个去相等的参数。（引用的是地址产生的问题）



 

as 

①import语句中的as：可以将导入的模块或其中的函数、类、变量等指定一个本地别名，以便在代码中更方便地引用。

②with语句中的as：可以将with语句中创建的对象指定一个本地别名，以便在with语句块中更方便地使用。



### 局部变量和全局变量

**全局变量**是整个程序，函数都可以访问的，但是**局部变量**（**函数内的变量**）只有函数内可以引用。

二者若同名（**局部的变量需要先定义**，不能直接处理，否则电脑会认为是想修改全局变量），则**在局部内用局部的变量**，**在外用全局变量**

在函数中**更改全局变量需要**使用 **`global`**，来进行声明：**`global a`**

 

**修改可变类型**的全局变量**可以不用global**也可以修改其值

 

**不可变类型则是必须用global**进行修改

 

1.如果在函数调用时没有指定实参的名称，则函数将按照形参在函数定义中出现的顺序进行赋值，并将每个实参依次赋值给对应位置的形参。

 

2.如果在函数调用时指定了实参的名称，则函数将按照指定的名称与形参进行匹配，而不是按照位置进行匹配。这样做可以避免因为实参的位置错误导致的语义错误。

 

3.如果在函数定义中给形参指定了默认值，在函数调用时，如果未传递该形参对应的实参，则会使用该形参的默认值来进行运行。如果传递了实参，则实参的值会覆盖默认值。

### lambda

小def

在 Python 中，lambda 表达式可以用于创建一些简单的函数，定义一个匿名函数，而不需要显式地定义一个函数，类似于简单的def。冒号前是形参，冒号之后是返回值。例如：

lambda x: x**2 

定义一个匿名函数，计算输入参数的平方值

###  eval 

eval是 Python 中的一个内置函数，它可以将字符串作为表达式求值，并返回结果。通俗一点说，eval 函数可以把一个字符串当做一段 Python 代码来执行。是真的当成代码来执行

例如，你可以使用 eval 函数来计算一个字符串类型的数学表达式：

```python
expr = "3 + 4 * 2"

result = eval(expr)

print(result) 
>11
```

在这个例子中，expr 是一个字符串类型的表达式，包含加、乘等操作符和数字。然后，我们使用 eval 函数对这个表达式求值，并将结果赋值给 result 变量。最终，result 的值为 11，这是表达式 "3 + 4 * 2" 的计算结果。

## string方法

| 函数                                     | 作用                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| **`capitalize()`**                       | 将字符串的第一个字母转换为大写，其余字母转换为小写           |
| **`casefold()`**                         | 进行全小写转换，比 `lower()` 更为激进，能够处理特殊字符。    |
| **`center(width[, fillchar])`**          | 将原字符串居中对齐并使用 `fillchar` 填充至指定的 `width` 长度得到的。 |
| **`count(sub[, start[, end]])`**         | 返回子字符串 `sub` 在字符串中出现的次数，可以指定开始和结束位置。 |
| **`encode(encoding[, errors])`**         | 将字符串编码为指定的编码格式。                               |
| **`endswith(suffix[, start[, end]])`**   | 检查字符串是否以指定的后缀结束，可以指定开始和结束位置。     |
| **`expandtabs([tabsize])`**              | 将字符串中的制表符（`\t`）扩展为相应数量的空格。             |
| **`find(sub[, start[, end])`**           | 查找子字符串 `sub` 在字符串中的位置，可以指定开始和结束位置。 |
| **`format(\*args, \**kwargs)`**          | 格式化字符串，使用 `{}` 作为占位符。                         |
| **`format_map(mapping)`**                | 类似于 `format()`，但使用字典映射来替换占位符。              |
| **`index([, start[, end]])`**            | 与 `find()` 类似，但如果没有找到子字符串，则引发 `ValueError`。 |
| **`isalnum()`**                          | 检查字符串是否至少包含一个字母或数字，且不包含其他字符。     |
| **`isalpha()`**                          | 检查字符串是否只包含字母。                                   |
| **`isdigit()`**                          | 检查字符串是否只包含数字。                                   |
| **`isspace()`**                          | 检查字符串是否只包含空白字符。                               |
| **`islower()/isupper()`**                | 检查字符串中的所有字母是否都是小/大写。                      |
| **`istitle()`**                          | 检查字符串是否遵循标题大小写规则（每个单词的首字母大写）。   |
| **`join(iterable)`**                     | 将迭代对象中的元素连接成一个字符串，元素之间用当前字符串作为分隔符。 |
| **`lower()/upper()`**                    | 将字符串中的所有大写字母转换为小/大写。                      |
| **`lstrip([chars])/`rstrip([chars])**    | 移除字符串左/右侧的特定字符（默认为空格）。                  |
| **`strip([chars])`**                     | 移除字符串两侧的特定字符（默认为空格）。                     |
| **`replace(old, new[, count])`**         | 将字符串中的子字符串 `old` 替换为 `new`，可以指定替换的次数。 |
| **`split(sep=None, maxsplit=-1)`**       | 根据分隔符 `sep` 将字符串分割为一个列表，可以指定最大分割次数。 |
| **`splitlines([keepends])`**：           | 将字符串按行分割为一个列表，可以指定是否保留行尾的换行符。   |
| **`zfill(width)`**                       | 返回一个字符串，它是通过在字符串的左侧填充 `0` 来达到指定的 `width` 长度。 |
| **`title()`**                            | 将字符串的每个单词的首字母转换为大写。                       |
| **`startswith(prefix[, start[, end]])`** | 检查字符串是否以指定的前缀开始，可以指定开始和结束位置。     |
|                                          |                                                              |





## List的相关方法

`列表名=list(字符串)`可以直接将字符串内的内容全转为列表的元素（**仅限于字符串**）其中的每个字符转化成一个元素

- 任何迭代器用`[]`包裹都可以实现转为列表。
- 如果添加列表于列表内，列表的元素会是列表 
- List可以像字符串一样进行`+ *` 操作 




特殊创建方法：（在list内直接填写list的value条件）

```python
new_ls = [i for i in ls if i % m != 0]
```

这个新列表的的value添加方法可以直接写在里面

```python
List=[参数 for 参数 in 范围 if 满足何种条件]（条件可不写）
```

 也可以是

```python
list = [1 if a==1 else -1 for a in y] #会将y当中的元素转为1或者-1
```



### 列表推导式

 列表推导式： 

```
[expression for item in iterable if condition]
```

其中

`expression` :是对每个元素执行的操作，可以是任意表达式；

`item` :是从 iterable 中迭代获取的每个元素；

`iterable`: 是一个可迭代对象，比如列表、元组、集合等；

`condition`: 是一个可选的条件表达式，如果不满足条件则不返回。

eg1:

```python
ls=[x for x in range(100) if x%13==0]#以100以内可以被13整除的值组成列表
```

 

eg2:

```python
squares = [x ** 2 for x in range(1, 11)]

print(squares) 

# 输出：[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] ，以1~10的平方数组成列表
```

 

eg3:

```python
words = ['apple', 'banana', 'pear']

lengths = [len(word) for word in words]

print(lengths) 

# 输出：[5, 6, 4]，以原列表内每个单词的词长组成列表

作用：通常用于快速生产一个新列表
```



过滤列表中的元素：

   List=[n for n in numbers if n % 2 == 0]

对列表中的元素进行计算：

List=[n ** 2 for n in numbers]

嵌套循环迭代：

 List=[(x, y) for x in range(3) for y in range(3)]



从字典中提取键值对：

List=[f"{k}={v}" for k, v in dict.items()]

### 增添

末尾插入

```python
strs.append(s)#将内容作为单一元素在末尾插入，也就说任意形式的迭代器也会以单一的形式插入
```

 拆开插入

```python
strs.extend(s)#将内容拆开多个单个元素从后插入
```

 精准插入

```python
strs.insert(位置i, "超人")#找到准确位置整体插入，后面的元素均向后移一位
```

 

### 删除

按照索引删除

```python
del strs[8]#删除某个位置（根据索引删除，易报错）
```

 范围删除

```python
del str[a:b]#删除从a到b-1（左闭右开原则）范围内的所有元素
```

 看注释

```python
strs.pop()#删除。pop（）也可以用()内的参数删除对应下标，默认删除最后一个元素。且pop()方法返回被删除的元素，因此您可以在删除元素的同时访问被删除的元素。
```

 

`remove()`:

```python
strs.remove(['超级战队','初号机'])#删除指定量,多个元素相同的情况下只删除列表内找到的第一个（根据元素进行删除）

strs.remove("奥特曼")#通过元素删除，但只对列表操作，并不会返回任何的值。
```

 

**经验**：del是通过索引来删除元素，而remove是通过元素的内容来删除元素。在使用del时，如果指定的索引超出了列表的范围，则会引发IndexError异常（索引异常）。而如果使用remove，则会尝试在整个列表中查找相应的元素并将其删除，如果元素不存在于列表中，则会引发ValueError异常（内容异常）。因此，在使用del和remove时，分别需要注意列表的边界情况和要删除的元素是否存在于列表中。

 

### 修改

索引修改

```python
strs[1]="初号机"#替换值，可以用索引直接替换更改
```

 

### 访问列表

```python
list[number] #访问元素

#访问元素内详细的值

For i in list #遍历元素
```

 

i[start: end: step]#取该元素的第几位到第几位 取 出方法如range()

## 元组的操作

（一个值非元组）

访问元组方法与list一致

元组**不可以删除**或者**添加**，但可以通过**两个元组相加的方式进行合并**，<u>因为合并是产生新元组而非修改。</u>

元组可以用`tuple.index()`（查找）和 `tuple.count()`（统计）（x, start, end）的格式。

index查找只会返回首位符合条件的元素的下标；且会在发现没有查找的元素返回一个`value error`



`zip()` 函数用于将多个可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。[(list1,list2),(····),(·····)]。

在 Python 3.x 中为了减少内存，zip() 返回的是一个对象。如需展示列表，需手动 list() 转换。



元组可用list()和tuple()函数与列表进行相互转换



## 字典的操作

不同于元组和列表，字典的范文才用[key]的方式来寻找value

dict = {'key':'value'}

`Key`必须是**不可变类型**

### 字典的创建

```python
dict={x:y}

    dict(x1=y1,x2=y2)

	dict(zip([list1],[list2]))#

推导式 dict(num: num**2 for num in range(1,10))
```



如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。

 

### 增加

字典可以通过`dict[key]=value`的方式添加新键值对

函数上添加

```python
dict.setdefault(key,value)#增加，格式上直接输入key,value即可只能输入一对，且key如若是字符串需要带引号。
```



### 删除

字典删除采用del以及clear()：

按key删除

```python
del dict['age']#删除某个
```

全删

```python
dict.clear()#全删
```

删除末位并返回元组

```python
dict.popitem()#删除最后的键值对，并返回键值对（元组）
```

删除精确位置返回key

```python
dict.pop()#删除一个精确的键值对，并且返回键
```

添加也可以修改

```python
dict.update()#添加和修改：格式采用xxx=xxx，不需要引号，可多个
```



直接遍历dict，用的是键。用值需要`dict.values()`，用键值对需要`dict.items()`



### 查

get查找

```python
dict.get(key, value) #此处并非一对键值对。查找键key的value，若字典内没有键key，则会返回value来说明并没有这个key
```

统计键值对数目

```python
len(dict) #用于统计键值对的数量
```

判断

```python
dict.has_key(key) #判断字典内是否含有key键返回false和true
```

访问键值，键值对

```python
dict.keys()/values()/items() #用于访问所有的键，值，列表
```

补充：

`list[start : end : step]` #**切片操作**

属于拷贝操作，产生一个新的项目，所以对新项目进行操作的时候不会对原来的序列有什么影响

### 改

`dict.update()`-添加和修改：格式采用xxx=xxx，不需要引号，可多个。



## 文件 



**IO：  input  output(输入输出)**

 

input:从文件当中读取内容到内存

 

output:把内存当中的内容输出到硬盘

 

相对路径：文件名或者路径名 demo 123.txt

 

绝对路径：//Windows  C://        linux /      #和代码所在的盘

```python
filename = "example.txt"
content_to_write = "这是写入文件的内容。\n"

# 创建或打开文件进行写入
file = open(filename, 'w')
file.write(content_to_write)
file.close()  # 记得关闭文件释放资源，否则会报错
#且如果想用另一个模式对file进行操作也需要close


# 打开文件进行读取
file = open(filename, 'r')
content = file.read()
print(content)  # 打印文件内容
file.close()  # 记得关闭文件


# 打开文件进行追加
additional_content = "这是追加到文件的内容。\n"
file = open(filename, 'a')
file.write(additional_content)
file.close()  # 记得关闭文件
```

 

### 打开文件：

open(文件名，访问模式)#可以打开一个已经存在的文件，也可以新建一个文件，创建文件取决于访问模式

输入数据：

.write(str)#在允许写入的访问模式下才可以引用的代码

 

### 读取数据

files(文件在python中的参数).read(num)#num是读取长度（在python2中单位是字节），**默认是读取所有的数据**，若之前已经读取过了，后续的读取是读取未被读取的部分

 

`.readlines()`     #和read的格式一样，按照行的方式将整个内容一次性读取并且返回一个列表，每一行就是一个元素(**会读取\n加入元素内**)，读取未读取过的部分同样适用于readlines（如果有一行为空，则取到最后一个空行的前一行；**中文不能取，会发生乱码**；）

### 访问模式

| 字符 | 模式                                                         |
| ---- | ------------------------------------------------------------ |
| r    | 只读模式，指针放在文件开头。默认模式                         |
| w    | 打开一个文件只用于写入。已存在的文件会覆盖，如果不存在则会创造对应新文件 |
| a    | 打开一个文件用于追加。如果文件已经存在，则指针位于文件结尾，也就是在文件的末尾写入。如果文件不存在，则创建新文件写入。 |
| rb   | 以二进制格式打开一个文件，用于只读                           |
| wb   | 同上                                                         |
| ab   | 同                                                           |
| r+   | 用于读写，指针也在文件开头                                   |
| w+   | 用于读写，如果该文件已经存在则覆盖，不存在则创建。           |
| a+   | 用于读写。同                                                 |
| rb+  | .......                                                      |

f.close()#关闭文件

 

f.name#取文件的名称，包括拓展名

 

f.encoding#获取文件的编码方式

 

f.tell()#用于获取当前读取到的位置，即已经读取的长度

 

f.seek(offset,from)#读写文件过程中需要从另一个位置进行操作。offset是偏移量，from是方向：0是开头，1是当前位置，2是末尾



```python
def write_file(filename, content):
    with open(filename, 'w') as file:
    # with语句打开文件时，文件会在 with 块执行完成后自动关闭
        file.write(content)
    print(f"文件 '{filename}' 已被写入内容。")

# 读取文件
def read_file(filename):
    try:
        with open(filename, 'r') as file:
            content = file.read()
            print(f"文件 '{filename}' 的内容是：")
            print(content)
    except FileNotFoundError:
        print(f"文件 '{filename}' 未找到。")

# 追加内容到文件
def append_to_file(filename, content):
    with open(filename, 'a') as file:
        file.write(content)
    print(f"内容已被追加到文件 '{filename}'。")

# 使用示例
if __name__ == "__main__":
    # 定义文件名
    filename = "example.txt"

    # 写入内容到文件
    write_file(filename, "这是文件的初始内容。\n")

    # 读取文件内容
    read_file(filename)

    # 追加内容到文件
    append_to_file(filename, "这是追加的内容。\n")

    # 再次读取文件内容
    read_file(filename)
```



##  random库

pyrhon的一个基础库，不需要额外下载。

在 Python 的 `random` 模块中，给定的范围通常是一个半开区间，即左闭右开区间）

**rd.shuffle(seq)**：随机打乱序列 seq 中的元素，**不会创建一个新副本**，而是**打乱传入的对象**

```python 
import random as rd
num = [1,2,3,4,5,6]
rd.shuffle(num)
print(num)
>[1, 6, 5, 2, 3, 4]
```

**rd.choice(seq)**：从序列 seq 中随机选择一个元素并返回

```python
import random as rd
num = [1,2,3,4,5,6]
a=rd.choice(num)
print(a)
>1
```

**rd.randint(a, b)**：返回一个从 a 到 b（包括 a 和 b）之间的随机整数

```python
import random as rd
a=rd.randint(0,10)
print(a)
>7
```

**rd.random()**：()内无需参数，返回一个 [0,1） 之间的随机浮点数

```python 
import random as rd
a=rd.random()
>0~1
```

**rd.seed()**：设置随机数的种子值（种子值决定了生成的随机序列，默认是系统的时间。如果种子值相同，则生成的序列也相同。因此，可以使用这个函数来保证程序每次运行时生成相同的随机数序列。)

例如，在实验或测试中需要固定生成的随机数序列以便进行比较或重复验证时，就可以使用该函数。

seed能够帮助我们生成固定的随机数序列。参数可以任意类型，但是传入参数才有效。

```python
import random as rd
rd.seed(1)
print(rd.random())
>0.13436424411240122
```

**rd.uniform(a, b)**：函数来生成a到b范围内的随机小数[a,b)

```python 
import random as rd
a=rd.uniform(10,20)
print(a)
>10.016896634129942
```

计算机中的随机数通常是**基于当前时间来生成的**，也就是所谓的**伪随机数**。在程序中我们可以使用各种算法来生成这些随机数，但是它们都<u>不能真正做到完全随机，因为它们都有一定的规律可循</u>

## os

文件夹

os.rename(“旧的名称”，“新的名称”)#重命名

 

os.remove(“名称.拓展名”)#删除文件

 

os.mkdir(“文件夹的名称“)#创建文件夹，可以用//表明相对路径，在某个文件夹之下再创建文件夹

Windows下python不能创建多级目录

os.rkdir(‘名称‘)#删除文件夹

 

## 异常处理：

```python
try:

  代码内容（主码）

Except（error1）:

  出错后执行的代码

Except（erro2）:

  ……
```

异常代码的执行原则：因为python是一行一行编译的，他在try处的主码内容，所产生的报错必然是第一个错误，所以主码的报错以主码出现的第一个错误为主。在except中同样，查询到主码的第一个错误后，与第一个相符的except内的错误条件匹配后，有且仅运行此except下的出错后执行的代码。

 

补充：

- 若主码内的代码是没有错误的，其本身是可以正常运行的
- 可用在except后补充as result来捕捉异常的基本信息

- except Exception 可以用来捕捉所有的异常

- 在try中else同样可用，即如果没有捕获到异常，则执行else下的代码内容 

- 在try中可用finally，用法与else类似，不同点在于finally在整段代码中，无论try的代码出现了怎样的问题（异常能捕获，不被捕获，无异常，报了其他的错误……），他仍可以继续运行。（主要用于资源回收） 
- try不能捕获所有可能的错误。有些错误可能会导致程序崩溃或无法恢复，例如操作系统故障、硬件问题等。在这种情况下，即使使用了异常处理也无法解决问题。

 





## 函数

### Sorted函数:

sorted() 是 Python 的内置函数，它用于对可迭代对象进行排序。sorted() 可以接受一个可迭代对象作为参数，返回一个新的已经排序的列表，不影响原来的可迭代对象。语法如下：

sorted(iterable, *, key=None, reverse=False)

其中：

 

iterable：表示要排序的可迭代对象，例如列表、元组、集合等。

 

key：可选参数，表示一个用于排序的函数，可以指定函数或 lambda 表达式，用于提取比较关键字。默认值为 None，表示使用元素本身进行比较。

reverse：可选参数，表示是否按照逆序（降序）排列。默认值为 False，表示按照升序排列。

例如：

我们可以使用 sorted() 将一个列表按照升序排列：

nums = [5, 2, 1, 3, 4]

result = sorted(nums)

print(result)  # 输出：[1, 2, 3, 4, 5]

在这个例子中，我们将列表 nums 作为参数传递给了 sorted() 函数，然后得到了一个新的已经排序好的列表 [1, 2, 3, 4, 5]。

 

如果需要按照其他规则进行排序，可以使用 key 参数指定一个函数或 lambda 表达式。例如，我们可以按照字符串长度将一个列表中的字符串排序：

words = ['apple', 'banana', 'pear', 'orange']

result = sorted(words, key=lambda x: len(x))

print(result) # 输出：['pear', 'apple', 'banana', 'orange']

在这个例子中，我们指定 key 参数为 lambda x: len(x)，表示按照字符串长度进行排序。最终得到了一个已经按照字符串长度排序好的列表 ['pear', 'apple', 'banana', 'orange']。

需要注意的是，sorted() 函数返回的是一个新的已经排好序的列表，不会修改原来的可迭代对象。如果要对原来的可迭代对象进行排序，可以使用 sort() 方法。

 

### Strip

strip() 是字符串对象的一个方法，它用于去除字符串首尾的符合条件的字符（默认为空格符，一直符合一直去除）。语法如下：

str.strip([chars])

其中，chars 参数是可选的，用于指定要去除的字符集合。如果未指定 chars，则默认去除字符串首尾的空格符。

会生成一个新的字符串，而不会改变原先的字符串，且只处理左右首位符合条件的字符，而不会处理串内的符合的首个字符。

 

Sort():

sort()是一个Python内置的列表方法，用于对列表进行排序操作。它可以按照升序或降序的方式对列表中的元素进行排序，并且默认情况下是按照升序排序。排序后的结果会直接作用于原始列表，而不是创建一个新的列表。

 

例如，如果有一个包含整数的列表，可以使用sort()方法将它们按升序排序：

numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]

numbers.sort()

print(numbers)

输出：

[1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]

还可以通过reverse参数来控制排序的顺序，如果reverse=True，则按照降序排序：

numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]

numbers.sort(reverse=True)

print(numbers)

输出：

[9, 6, 5, 5, 5, 4, 3, 3, 2, 1, 1]

 

### reverse():

是一个Python内置的列表方法，用于将列表中的元素反向排序。它会直接修改原始列表，而不是创建一个新的列表副本。

例如，有一个包含整数的列表，可以使用reverse()方法将它们反转：

numbers = [3, 1, 4, 1, 5, 9, 2]

numbers.reverse()

print(numbers)

输出：

[2, 9, 5, 1, 4, 1, 3]

需要注意的是，reverse()方法没有参数，只能按照元素在列表中出现的顺序进行反转，不能像sort()方法那样指定升序或降序。如果需要按照特定的顺序进行反转，可以先使用sort()方法进行排序，然后再使用reverse()方法进行反转。且reverse()是在原来的列表上进行的操作,并不会返回任何值。

 

### raise（抛出错误处理）:

在Python中，raise是一个关键字，用于引发异常（也可以称为错误）。当程序运行到raise语句时，会立即停止当前执行的代码块，并抛出指定类型的异常。这个异常将会沿着函数调用栈向上传递，直到被捕获或者导致程序崩溃。

raise语句通常用于以下几种情况：

1.检查函数参数的有效性。例如，在处理输入时，我们希望确保输入值满足特定的条件，否则就抛出异常并提供相关信息。

2.在程序运行时检测错误条件。例如，如果尝试访问一个不存在的文件，并且我们没有对这种情况进行处理，那么程序就会崩溃。但是，如果我们使用raise语句来抛出FileNotFoundError异常，就可以在运行时检测到错误，从而使得程序可以优雅地退出或提供更好的错误信息。

3.在自定义类中实现异常。通过定义自己的异常类，我们可以控制异常的行为和错误信息，并将其与Python内置异常区别开来。

 

集合（set）:

集合具有无序性(但可用sorted进行排序)，互异性，确定性。

age:   a={1,3,2,2,4,6}

​      print(a)

input: {1,3,2,4,6} 此处可见集合具有无序性，且发生了去重可见集合具有互异性。因而不能用下标进行查找，也不能切片

集合的操作：

增添：

set.add()-添加

set.dpdate()-更新，也可以理解为多个添加。update接收的参数应该是可迭代的数据类型，比如字符串、元组、列表、集合、字典。这些都可以向集合中添加元素，但是整型、浮点型不可以。

删减：

set.discard()-指定删除，不会报错直接忽略

set.remove()-指定删除，且会报错KeyError

set.pop()-删除首个，并且返回首个的值

创建和转换：

​         set(range(1,10))-创建例子，同list，可用推导式

​         set（（1，2，3，1，2，5））-set()函数转

 

推导式：

​         同列表推导式，个人认为同创建例子方法

 

集合运算：

​         s1|s2-合集运算

​         s1&s2-交集运算

​         s1-s2-差运算

​         s1^s2-异或运算

emumerate(sequence, start): 用于将一个可遍历的数据对象(sequence如列表、元组或字符串)组合为一个索引序列，同时列出从start开始的数据和数据下标

 

### ceil: math函数，表明向上取整。

生成器（generator）主要为了节省内存：

属于一种自建函数，但区别在于有return的函数直接返回结果，程序终止不再运行，并销毁局部变量。而yield结尾的函数，则会生成一个生成器你可以用for循环或者调和next()方法遍历生成器对象来生成结果。

底层运作原理是：调用生成器函数过程中，每次遇到yield都会暂停保存当前的所有运行信息，返回yield的值，并且下次运行时继续在此处开始。直到全部遍历。

例子：

```
def gen(max):
       n = 0
       while n <max:
                    print(n)
                    n += 1
                    yield n
g=gen(10000)
```

需要一个全局变量来引用这个生成器。

 

## Statistics库:

格式：statistics.方法名(data)

方法： 

一．statistics.mean(data):

l 平均值

l 支持的输入非常多，包括fractions模块和decimal模块

\>>> mean([1, 2, 3, 4, 4])

2.8

 

\>>> mean([-1.0, 2.5, 3.25, 5.75])

2.625

 

\>>> from fractions import Fraction as F

\>>> mean([F(3, 7), F(1, 21), F(5, 3), F(1, 3)])

Fraction(13, 21)

 

\>>> from decimal import Decimal as D

\>>> mean([D("0.5"), D("0.75"), D("0.625"), D("0.375")])

Decimal('0.5625')

 

二．statistics.harmonic_mean(data):

l 调和平均数![img](file:///C:/Users/LLLLL/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif)

\>>> from statistics import *

\>>> harmonic_mean([1,2,3]) 

1.6363636363636365 

 

\>>> 1/sum([1./1,1./2,1./3])*3

1.6363636363636367

 

三．statistics.median(data)

l 中值

 

\>>> median([1, 3, 5])

3

 

\>>> median([1, 3, 5, 7])

4.0

 

四．statistics.median_low(data)

l 小中值

l 若中值有两个，则选择较小的那个

\>>> median_low([1, 3, 5])

3

 

\>>> median_low([1, 3, 5, 7])

3

 

五．statistics.median_high(data)

l 大中值

l 若中值有两个，则选择较大的那个

\>>> median_high([1, 3, 5])

3

 

 

\>>> median_high([1, 3, 5, 7])

5

 

六．statistics.median_grouped(data, interval=1)

l 用组距式来求分组数据中位数

公式：

中位数=中位数所在组下限+{[(样本总数/2-到中位数所在组下限的累加次数)/中位数所在组的次数]*中位数的组距}

参数说明：

interval：组距，

例子：

如果组距为1，则1在组0.5~1.5；

如果组距为2，则3在组2~4

\>>> median_grouped([1, 2, 2, 3, 4, 4, 4, 4, 4, 5])

3.7

 

\>>> median_grouped([1, 3, 3, 5, 7], interval=1)

3.25

 

\>>> median_grouped([1, 3, 3, 5, 7], interval=2)

3.5

示例说明：

[1, 2, 2, 3, 4, 4, 4, 4, 4, 5]中位数在4这个分组里面

默认组距为1

所在分组的下限为3.5

样本总数为10

4分组里有5个数

小于3.5的有4个数

所以中位数为：

3.5+(10/2-4)/5*1=3.5+1/5=3.7

[1, 3, 3, 5, 7], interval=2，中位数在3分组里

组距为2

所在分组下限为2

总数为5

3分组里有2个数

小于2的有1个数

中位数：2+(5/2-1)/2*2=2+1.5=3.5

 

七．statistics.mode(data)

l 众数

\>>> mode([1, 1, 2, 3, 3, 3, 3, 4])

3

 

\>>> mode(["red", "blue", "blue", "red", "green", "red", "red"])

'red'

 

八．statistics.pstdev(data, mu=None)

l 总体标准差

l 设定已知均值mu可以减少计算量

\>>> pstdev([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])

0.986893273527251

 

九．statistics.pvariance(data, mu=None)

l 总体方差

l 设定已知均值mu可以减少计算量

\>>> data = [0.0, 0.25, 0.25, 1.25, 1.5, 1.75, 2.75, 3.25]

\>>> pvariance(data)

1.25

 

十．statistics.stdev(data, xbar=None)

l 样本标准差

\>>> stdev([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])

1.0810874155219827

 

十一．statistics.variance(data, xbar=None)

l 样本方差

\>>> data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]

\>>> variance(data)

 

## Math库（数学库）：

math.floor(data)—将数字data向下取整

math.ceil(data)—将数字data向上取整

 

math.comb(x,y)—表示Cxy，一个无重复无顺序的排列总和

math.perm(x,y)—表示Axy无重复有顺序的排列总和

 

math.prod(liberate)—计算一个可迭代项的元素的积

 

math.isnan(x)—判断类，NaN(not a number—不是数字)，不是数字则返回True与isdigit相反，但是仅支持输入数字判断。

以此会发现，如果按照运行条件，isnan会永远输出false。实则不然。

引入：在python中我们可以用float("inf"), float("-inf")来分表代表正无穷和负无穷。也可以用 float('nan')来表明一个无效数字，有且仅有 float('nan')可以使isnan输出True.

 

math.dist(x,y)—返回一个x与y的欧式距离（可以是多维但二者维度需要相同）
