## Java的特性

#### 1.简单

Java比C++简单，你只需要意识到C比Java难就行，因为Java中并没有C中的指针变量、多重继承、头文件、运算符重载等复杂的知识点。采用`引用`代替了C语言中的指针，且有**<u>自动垃圾回收机制</u>**避免了C语言的内存容易溢出问题。同时Java也比C运行的速度更慢。

#### 2.平台无关性

Java的一个显著优点就是提供了**平台无关性**：即你可以在任意操作系统上使用完全一样的代码。也就是**一次编写，随处运行**。因为Java的运行都会先编译成一个`.class`文件（一个二进制文件）。再用其自带的一个虚拟机，即`JVM`，来运行代码。因为在任何操作系统上，其所做的工作均为——编译，用虚拟机运行。因而在不同的操作系统上，都可以运行Java程序，其整体的运行仅仅与编译后的`.class`文件和`JVM`相关

#### 3.面向对象

Java是一门面向对象（Object Oriented，简称OO）的语言，**面向对象**与**面向过程**是两种有代表性的编程思想；面向对象思想有三大特征：**封装**、**继承**、**多态**。

#### 4.交互式特性，多线程机制

由于Java支持`TCP/IP`协议（计算机网络中的协议），使得用户可以通过浏览器访问到Internet上的各种动态对象。并且在网络上用户可以交互式地进行各种动作，而多线程技术的引入使得这种交互式操作更为容易。同时可以多个任务并发执行。

#### 5.鲁棒性

鲁棒性又称作健壮性，指的是Java作为强类型语言必须要求有明确的变量类型，在发生异常时，Java能够统一处理异常事件。这也是Java被选作作用于开发IDE的重要原因。Java本身十分严谨。

#### 6.分布式

提供了用于网络应用编程的类库，Java的RMI(远程方法调用)机制是开发分布式应用的重要手段。支持各种层次的网络连接。

#### 7.动态内存管理机制

C++最大的问题是因为其语言自身难度问题，易发生内存溢出。Java针对这一问题设置有一个垃圾回收器，可以对程序中产生的对象进行跟踪，而对无用的对象释放其内存进而避免了内存溢出的问题。

#### 8.安全性

Java语言在安全性方面引入了实时内存分配及布局来防止程序员直接修改物理内存布局;通过字节代码验证器对字节代码的检验，以防止网络病毒及其它非法代码侵入。





### 面向对象

面向对象（Object-Oriented，OO）是一种编程范式，它将现实世界中的实体抽象为对象，通过对象之间的交互来设计和构建软件系统。

面向对象的**核心概念**包括：

- **对象（Object）**： 对象是现实世界中事物的抽象，它包含**属性（数据）**和**方法（行为）**。例如，一个银行账户（BankAccount）可以是一个对象，它有属性（如账户余额）和方法（如存款、取款）。
- **类（Class）**： **类是对象的蓝图或模板**，定义了对象的属性和方法。<u>类可以被用来创建多个对象实例</u>，这些实例共享相同的属性和方法，但各自拥有独立的属性值。

面向对象的**特性**：

- **封装（Encapsulation）**： 封装是将数据（属性）和操作这些数据的方法组合在一起，并隐藏内部细节，只<u>提供必要的接口</u>。这样，对象的内部实现可以独立于外部变化，提高了代码的安全性和可维护性。
  - Java 的三个访问权限关键字：`public`（公开的，）， `private`（）, `protected`（）。
  - `default` （包访问）：该权限下的资源可以被同一包（库组件）中其他类的成员访问。
- **继承（Inheritance）**： 继承是一种机制，允许一个**类（子类或派生类）**继承另一个**类（父类或基类）**的属性和方法。这支持了代码的重用，并可以建立类之间的层次结构。“是一个”与“像是一个”
- **多态（Polymorphism）**： 多态是<u>指对象可以有多种形式，允许不同类的对象对同一消息做出不同的响应</u>。在面向对象编程中，这通常通过**方法重载（同名方法在不同类中有不同的实现）**和**方法覆盖（子类重写父类的方法）**来实现。
  - 我们在处理类的层次结构时，通常把一个对象看成是它所属的**基类**，而不是把它当成具体类。通过这种方式，我们可以编写出不局限于特定类型的代码。
  - 这样的代码不会受**添加的新类型影响**，并且添加新类型是扩展面向对象程序以处理新情况的常用方法。
  - 面向对象语言使用**后期绑定**的概念。当向对象发送信息时，被调用的代码直到运行时才确定。
  - 在 Java 中，动态绑定是**默认行为**，不需要额外的关键字来实现多态性。
  - 把子类当成其基类来处理的过程叫做“**向上转型**”（**upcasting**）。

面向对象编程的优点包括：

- **提高代码的可重用性**：通过继承和多态，可以创建可重用的代码组件。
- **提高可维护性**：封装使得代码更容易理解和维护，因为每个对象都是一个独立的模块。
- **提高可扩展性**：新的功能可以通过添加新的类或修改现有类来轻松添加，而不影响现有系统的其他部分。
- **提高代码的可读性**：面向对象的代码通常更接近自然语言，因为它模仿了现实世界的实体和它们之间的关系。



### 对象

#### 对象操作

- 我们所操纵的标识符实际上只是对对象的**“引用”**。

举例：我们可以用遥控器（引用）去操纵电视（对象）。只要拥有对象的“引用”，就可以操纵该“对象”。



#### 对象清理

作用域：

- 作用域是由大括号 `{}` 的位置决定的。
- 在 C/C++ 中将一个较大作用域的变量"隐藏"起来的做法，在 Java 中是不被允许的。



对象作用域：

- 当我们使用 `new` 关键字来创建 Java 对象时，它的**生命周期**将会<u>超出作用域</u>。
- Java 的垃圾收集器会检查所有 `new` 出来的对象并<u>判断哪些不再可达，继而释放那些被占用的内存，供其他新的对象使用</u>。



#### 数据存储

- **寄存器**
- **栈内存**
  - Java 系统**必须**知道**栈内保存**的<u>所有项的生命周期</u>。这种约束限制了程序的灵活性。
  - 在栈内存上存在一些 **Java 数据（如对象引用）**，但<u>Java 对象本身的数据却是保存在堆内存的</u>。
- **堆内存**
  - 通用的内存池（也在 RAM 区域），<u>所有 Java 对象都存在于其中</u>。
  - 与栈内存不同，编译器不需要知道对象必须在堆内存上停留多长时间。因此，<u>用堆内存保存数据更具灵活性</u>。
  - 分配和清理堆内存要比栈内存需要更多的时间。
  - 随着时间的推移，Java 的堆内存分配机制现在已经非常快。
- **常量存储**
  - 直接放在程序代码中
- **非 RAM 存储**
  - **序列化对象**：对象被转换为字节流，通常被发送到另一台机器。
  - **持久化对象**：对象被放置在磁盘上，即使程序终止，数据依然存在。





### 其他概念

#### **集合**

- 在 Java 中**“集合”（Collection）**的使用率比数组更高。（也可称之为“容器”，但“集合”这个称呼更通用。）
- 集合的选择：
  - 集合可以提供不同类型的接口和外部行为。
  - 不同的集合对某些操作有不同的效率。
  - 例如，List 的两种基本类型：ArrayList 和 LinkedList。虽然两者具有相同接口和外部行为，但是在某些操作中它们的效率差别很大。
- 参数化类型机制（Parameterized Type Mechanism）称之为“泛型”（Generic）



#### **生命周期**

- Java 使用**动态内存分配**。
- 在堆内存（Heap）中动态地创建对象，直到程序运行我们才能确定需要创建的对象数量、生存时间和类型。什么时候需要，什么时候在堆内存中创建。 因为内存的占用是动态管理的，所以在运行时，在堆内存上开辟空间所需的时间可能比在栈内存上要长（但也不一定）。在栈内存开辟和释放空间通常是一条将栈指针向下移动和一条将栈指针向上移动的汇编指令。开辟堆内存空间的时间取决于内存机制的设计。
- 合理假设：对象通常是复杂的，相比于对象创建的整体开销，寻找和释放内存空间的开销微不足道。
- 在堆内存创建对象的话，编译器是不知道它的生命周期的。
- Java 的内存管理是建立在**垃圾收集器**上的，它能自动发现对象不再被使用并释放内存。



#### **异常处理**

- 异常处理机制将程序错误直接交给编程语言甚至是操作系统。
- “异常”（Exception）是一个从出错点“抛出”（thrown）后能被特定类型的异常处理程序捕获(catch)的一个对象。它不会干扰程序的正常运行，仅当程序出错的时候才被执行。



## Java的加载与执行



### Java文件的运行

假设我们有一个待执行的文件 `helloworld.java`其在计算机中运行时需要经历什么工序呢？

首先我们的`helloworld.java`文件会被`Javac`编译成一个**二进制文件**，这个`Javac`的含义不言而喻即为`Java compile`的缩写`helloworld.class`，也就是**字节码文件**。字节码文件会通过**类加载器**被搬运到`JVM`中，然后在`JVM`中运行。

### `JVM` - Java虚拟机

虚拟机主要的 5 大块，可以分为两个区域，分别为**线程共享区域**和**线程独享区域**。其中线程共享区存在着线程安全问题，因为线程独享区的每个线程独享内存因而没有线程安全问题。

**方法区**，**堆**都为**线程共享区域**

**栈**、**本地方法栈**和**计数器**都是**线程独享区域**，其不存在线程安全问题。

而 `JVM` 的调优主要就是围绕**堆，栈**两大块进行

#### 线程共享区域

线程共享区是指多个线程可以访问和修改的内存区域。在共享区内，数据和资源是共用的，一个线程的修改可以被其他线程看到。包括方法区和堆区。

##### 方法区

方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。与堆一样，方法区也是由所有线程共享的。在Java 8之前，方法区通常被称为永久代（PermGen），用于存储类的元数据。从Java 8开始，永久代被元空间（Metaspace）所取代，元空间不再处于虚拟机内存中，而是使用本地内存。

方法区用于存放类似于元数据信息方面的数据的，比如类信息，常量，静态变量，编译后代码···等。

类加载器将 `.class` 文件搬过来都先丢到这一块上。

##### 堆

堆是Java虚拟机所管理的内存中最大的一块区域，用于存储对象实例和数组。它是所有线程共享的，几乎所有的对象实例和数组都在堆上分配内存。堆是垃圾回收器管理的主要区域，因此常被称为GC堆。堆可以进一步细分为新生代和老年代，新生代又可细分为Eden区、Survivor区等。

主要放了一些存储的数据，比如对象实例，数组等。它和方法区都同属于 **线程共享区域** 。也就是说它们都是 **线程不安全** 的



#### 线程独享区

线程独享区是指每个线程拥有的独立内存区域，其他线程无法访问。每个线程的独享区是隔离的，数据和资源是私有的。包括程序计数器和栈区。

##### 栈

这是我们的代码运行空间。每个线程在创建时都会分配一个私有的栈空间，用于存储局部变量、操作数栈、动态链接和方法出口等信息。每个方法执行时，都会创建一个栈帧（Stack Frame），我们编写的每一个方法都会放到 **栈** 里面运行。用于存储局部变量表、操作数栈、动态链接、方法出口等信息。方法执行完毕后，栈帧会被弹出栈，释放相应的内存空间。

我们会听说过 **本地方法栈** 或者 **本地方法接口** 这两个名词，与虚拟机栈类似，本地方法栈用于存储执行本地（native）方法的数据。本地方法栈是Java虚拟机（JVM）内存模型中的一部分，用于支持本地方法的调用。不过我们基本不会涉及这两块的内容，它俩底层是使用 C 来进行工作的，和 Java 没有太大的关系。

##### 程序计数器

这是一块较小的内存空间，用于存储当前线程正在执行的字节码的地址。它是线程私有的，每个线程都有一个独立的程序计数器，用于记录当前执行的指令位置。当线程执行Java方法时，计数器记录的是正在执行的虚拟机字节码指令地址；如果执行的是Native方法，则计数器的值为空。这是唯一一个不会出现`OutOfMemoryError`的区域。

主要就是完成一个加载工作，类似于一个指针一样的，指向下一行我们需要执行的代码。

和栈一样，都是 **线程独享** 的，就是说每一个线程都会有自己对应的一块区域而不会存在并发和多线程的问题。

形如下图：

![img](https://static001.geekbang.org/infoq/c6/c602f57ea9297f50bbc265f1821d6263.png)
