# 计算机底层

### 进制符号

计算机中主要使用二进制，用符号表示为`B`，八进制为`O`，十六进制为`H`，十进制为`D`。

### 浮点数

具体可以从**IEEE二进制浮点数算术标准（IEEE 754）**了解，IEEE 754是20世纪80年代以来最广泛使用的浮点数运算标准

在`C`的基础数据类型中我们介绍了整型数据的大小和范围的关系。这里我们专门开设专题介绍浮点数的范围和其大小的关联。在IEEE 754 格式浮点数由 3 个部分组成，分别是 **符号码**，**阶码**，**尾数码**。标准分为 3 个类型的浮点数：分别是 短浮点数 `float`，长浮点数 `double`，临时短浮点数 `long double`。三种类型的浮点数对应的符号码、阶码、尾数码如下图所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200920212951539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzcxMzUwMw==,size_16,color_FFFFFF,t_70#pic_center)

下面的讨论一律采用 float 类型进行。



### 编码

#### ASCII

#### BCD

#### 汉字编码



# 计算机数学

### 傅里叶变换

傅里叶变换是一种数学变换，它将一个信号或函数分解为不同频率的正弦波或复指数函数的和。这个概念最初由法国数学家约瑟夫·傅里叶在19世纪提出，用于解决热传导问题。傅里叶变换在许多科学和工程领域都有应用，包括信号处理、图像处理、量子物理和声学等。

傅里叶变换的基本思想是，任何周期性的波形都可以表示为不同频率的正弦波的叠加。对于非周期信号，傅里叶变换可以将其表示为连续频率的正弦波的积分。

#### 连续傅里叶变换（Continuous Fourier Transform, CFT）

对于一个连续时间信号 \( f(t) \)，其傅里叶变换定义为：
$$
F(\omega) = \int_{-\infty}^{\infty} f(t) e^{-j\omega t} dt
$$

$$
其中，F(\omega)  是频域表示， \omega  是角频率， j  是虚数单位。
$$



#### 逆傅里叶变换（Inverse Fourier Transform, IFT）

从频域回到时域，逆傅里叶变换定义为：
$$
f(t) = \frac{1}{2\pi} \int_{-\infty}^{\infty} F(\omega) e^{j\omega t} d\omega
$$


#### 离散傅里叶变换（Discrete Fourier Transform, DFT）

在数字信号处理中，我们通常处理的是离散信号。离散傅里叶变换是连续傅里叶变换的离散版本，用于处理离散时间信号 \( f[n] \)：
$$
F[k] = \sum_{n=0}^{N-1} f[n] e^{-j\frac{2\pi}{N}kn}
$$

$$
其中， F[k]  是离散频率域的表示， N  是信号的长度， k  是频率索引。
$$

#### 快速傅里叶变换（Fast Fourier Transform, FFT）

快速傅里叶变换是DFT的一种高效算法，可以快速计算DFT，其计算复杂度从  O(N^2^)  降低到 O(N log N)。

FFT在数字信号处理中非常重要，因为它允许实时或近实时的频域分析。

傅里叶变换在图像处理中的应用包括频域滤波、图像压缩和图像分析等。

例如，通过傅里叶变换，可以将图像从空间域转换到频率域，从而更容易地识别和处理图像中的不同频率成分。







# 计算机系统

## 流处理与批处理

### 批处理（Batch Processing）

数据处理时机：批处理通常在**数据积累**到一定量之后进行。这意味着<u>**数据会被存储起来**，直到有**足够的数据量**或者达到**预定的处理时间点**，然后一次性处理</u>。

数据处理方式：在批处理中，<u>数据被视为一批静态的记录集合</u>，处理过程通常是**一次性的**，处理完整个数据集后，任务结束。

适用场景：批处理适合于**不需要即时响应的场景**，如日志分析、大规模数据集的ETL（Extract, Transform, Load）操作、复杂的数据转换和计算等。



优点：可以优化处理过程，因为整个数据集都是已知的；适合处理大量数据；通常**容错性较好**。

缺点：无法处理实时数据；对于数据处理有延迟；不适合需要快速响应的应用。



### 流处理（Stream Processing）

数据处理时机：流处理是**实时进行**的，数据一产生或到达系统就**立即处理**。这意味着<u>数据以连续的流的形式被处理，而不需要等待数据积累</u>。

数据处理方式：在流处理中，<u>数据被视为不断流动的数据流</u>，系统持续**不断地处理**这些数据流。

适用场景：流处理**适合于需要实时或近实时响应的场景**，如实时监控、实时分析、在线推荐系统、实时欺诈检测等。

**优点**：能够实时处理数据，**适应性强**；可以快速响应事件；适合动态和不断变化的数据源。

**缺点**：可能需要更复杂的系统设计来保证数据的准确性和处理的**可靠性**；对于系统资源的要求可能更高。

#### 对比

批处理和流处理的主要区别在于**数据处理的时机和方式**。

**批处理**适合于<u>非实时的大规模数据处理任务</u>，而**流处理**适合于需要<u>快速响应的实时数据处理任务</u>。

随着技术的发展，一些现代的数据处理框架，如Apache Flink和Apache Spark（其Structured Streaming模块），已经能够同时支持批处理和流处理，这种模式有时被称为“**流批一体化**”或“**统一数据处理**”。

#### 流批一体架构

流批一体架构是一种新兴的数据处理模式，旨在解决传统 `Lambda` 架构(**数据处理架构**，包含一个`Batch layer`-批量层进行批处理；`Speed layer`-速度层进行流处理；`Serving layer`-服务层提供查询服务)中流处理和批处理分离所带来的**资源浪费**、**成本高**和**数据一致性**问题。流批一体架构允许使用同一套代码和 API 实现流计算和批计算，从而提高资源利用率，降低学习和维护成本，并确保数据的一致性。



## 冷启动与热启动

### 冷启动

**冷启动**是指在没有现有可用实例的情况下，需要**从头开始创建和初始化一个新的函数实例**。这涉及到从存储中提取代码包、启动容器、加载代码到内存以及初始化函数处理程序等步骤。由于这个过程涉及多个步骤，所以通常会有额外的延迟，这就是所谓的“冷启动”延迟。

### 热启动

**热启动**则是指当一个**函数实例已经存在并且处于空闲状态时**，新的请求可以直接使用这个“热”的实例来执行，而不需要重新经历初始化过程。在这种情况下，响应时间会更快，因为跳过了初始化步骤。

## 计算机交互界面

### GUI - Graphical User Interface

- `GUI`指的是**图形用户界面**，它通过图形化的方式展示信息和接收用户输入。用户可以通过鼠标、触摸屏或其他指针设备与界面上的图标、按钮、菜单等元素进行交互。
- `GUI`的优势在于**直观易用**，用户无需记忆复杂的命令，只需通过点击和拖拽等操作即可完成任务。

### CLI - Command Line Interface

- `CLI`指的是**命令行界面**，它通过文本命令来接收用户输入和展示输出。用户需要在命令行提示符后输入特定的命令和参数来执行操作。
- `CLI`的优势在于**灵活性高**和**自动化能力强**，对于熟练用户来说，可以通过脚本来批量执行复杂的任务。

### TUI - Terminal User Interface

也称为**基于文本的用户界面**(Text-based User Interface)

- `TUI`指的是**文本用户界面**，它**介于`GUI`和`CLI`之间**，通过文本菜单和布局来提供用户交互。用户可以使用键盘快捷键在不同的文本菜单中进行导航和选择。
- `TUI`的优势在于它不需要图形环境，因此在资源受限的系统或远程会话中非常有用。同时，它也提供了比`CLI`更直观的操作方式。



例如，某些基于文本的邮件客户端或文件管理器就使用了`TUI`，用户可以通过键盘在不同的选项中进行选择和操作。

`TUI` 应用程序通常也被认为是 `CLI` 应用程序，因为它们被限制在终端上。在我看来，你是否认为它们与 `CLI` 不同，这取决于你。





## 重定向

在操作系统中，重定向是一种将输入或输出从一个设备或文件流转移到另一个设备或文件流的过程。它允许用户在执行命令或程序时，将输出结果发送到指定的位置，或从指定位置读取输入数据。

在命令行界面中，重定向通常使用特殊的符号来实现。例如，`>`符号用于将命令的输出重定向到一个文件，`>>`符号用于将输出追加到文件的末尾，`<`符号用于从文件中读取输入数据。

重定向在操作系统中的应用非常广泛，可以用于将命令的输出保存到文件中，将错误信息输出到特定的位置，从文件中读取输入数据等等。它提供了灵活的方式来处理输入和输出，增强了命令行界面的功能和效率。

重定向是一种操作系统的功能，用于改变程序的标准输入、标准输出和标准错误输出的默认位置。通过重定向，我们可以将程序的输入、输出和错误信息从默认的终端（通常是屏幕）改变为其他设备或文件。

在命令行环境中，重定向使用特殊的符号来实现：

- `>` 符号用于将程序的标准输出重定向到文件中。例如，`command > output.txt` 将 `command` 的标准输出写入到名为 `output.txt` 的文件中，如果文件不存在则创建新文件，如果文件已存在则覆盖原有内容。
- `>>` 符号用于将程序的标准输出追加到文件中。例如，`command >> output.txt` 将 `command` 的标准输出追加到名为 `output.txt` 的文件末尾，如果文件不存在则创建新文件。
- `<` 符号用于将文件的内容作为程序的标准输入。例如，`command < input.txt` 将 `input.txt` 文件的内容作为 `command` 的标准输入。
- `2>` 符号用于将程序的标准错误输出重定向到文件中。例如，`command 2> error.txt` 将 `command` 的标准错误输出写入到名为 `error.txt` 的文件中。
- `2>>` 符号用于将程序的标准错误输出追加到文件中。例如，`command 2>> error.txt` 将 `command` 的标准错误输出追加到名为 `error.txt` 的文件末尾。

通过重定向，我们可以将程序的输出保存到文件中，或者从文件中读取输入，以及将错误信息输出到文件中，而不是显示在终端上。这样可以方便地处理程序的输入输出，并进行日志记录和错误调试。



### 管道  |

`|`在操作系统中称之为**管道（`Pipe`）**，管道是一种用于**进程间通信的机制**。

它可以在两个或多个进程之间建立一个通道，<u>**使得一个进程的输出可以直接作为另一个进程的输入**</u>。

管道通常是**单向**的，分为两种类型：匿名管道和命名管道。

- **匿名管道**：匿名管道是一种最简单的管道形式，**用于在父进程和子进程之间进行通信**。它只能在具有亲缘关系的进程之间使用，即父进程创建子进程后，它们之间可以通过管道进行通信。匿名管道是一种半双工的通信方式，即数据只能在一个方向上流动。
- **命名管道**：命名管道是一种具有命名的管道，可以在不具有亲缘关系的进程之间进行通信。它通过在文件系统中创建一个特殊的文件来实现，多个进程可以通过该文件进行读写操作。命名管道是一种全双工的通信方式，即数据可以在两个方向上流动。

管道在操作系统中的使用可以实现进程间的数据传输和协作处理。一个进程可以将输出数据写入管道，而另一个进程可以从管道中读取这些数据进行处理。通过管道，进程之间可以实现同步和互相通知，实现并发执行和协作处理的功能。

总之，管道是一种在操作系统中用于进程间通信的机制，可以实现数据的传输和协作处理。它是实现进程间协作和并发执行的重要工具。

#### 和重定向的区别

- **用途**：
  - `|` 用于在命令之间**传递输出流**，实现命令的链式执行。也就是其可以多次使用不断传递。
  - `>` 用于将命令的输出保存到文件中，覆盖或创建文件。也就是实现数据的end to end。
- **效果**：
  - 使用 `|` 时，数据流从一个命令流向另一个命令，**不会在磁盘上留下任何痕迹**。
  - 使用 `>` 时，数据流**被写入磁盘**上的文件，影响文件内容。
- **文件操作**：
  - `|` 不涉及文件的创建或修改，它**只涉及命令之间的数据流**。
  - `>` 涉及文件的创建或覆盖。

## 文件描述表单

在操作系统的内核中，文件描述表单是一个数据结构，用于表示打开的文件或设备的信息。

每当一个文件或设备被打开时，内核会为其分配一个文件描述符（File Descriptor），并将相关的信息存储在文件描述表单中。

文件描述表单通常包含以下信息：

1. 文件描述符（File Descriptor）：一个整数值，用于标识打开的文件或设备。
2. 文件打开模式（File Open Mode）：指定文件的访问模式，如读取、写入、追加等。
3. 文件位置指针（File Position Pointer）：记录文件当前的读写位置。
4. 文件状态标志（File Status Flags）：表示文件的状态，如是否可读、是否可写、是否已到达文件末尾等。
5. 文件权限（File Permissions）：指定文件的访问权限，如读、写、执行等。
6. 文件引用计数（File Reference Count）：记录有多少个进程当前正在使用该文件。

文件描述表单的存在使得内核能够有效地管理和控制打开的文件和设备，同时提供了对文件的操作和访问的接口。



## 维护

创建，管理，监督，运行。



## PCB

**PCB**（**Process Control Block**，**进程控制块**）是操作系统中**用于管理和控制进程**的一种**数据结构**。

每个正在系统中运行的进程都有一个对应的PCB，它包含了进程的重要信息，用于操作系统对进程进行管理和调度。

PCB通常包含以下信息：

1. **进程状态**：描述进程**当前的状态**，如运行、就绪、阻塞等。
2. **程序计数器**：存储进程当前**执行的指令地址**。
3. **CPU寄存器**：包括通用寄存器、栈指针等。
4. **进程调度信息**：包括进程的**优先级、调度队列指针**等。
5. **进程标识符**：唯一地标识一个进程，通常包括进程ID、父进程ID等。**也就是`PID`**。
6. **内存管理信息**：包括进程的**地址空间、页表**等。
7. **进程控制信息**：包括进程的权限、拥有的资源、打开的文件等。

PCB的存在使得操作系统能够对进程进行管理和调度。当操作系统需要切换进程时，它会保存当前进程的PCB，并加载下一个要执行的进程的PCB，从而实现进程的切换和调度。PCB也是操作系统实现进程间通信和同步的重要手段之一。

总之，PCB是操作系统中用于**<u>管理和控制进程的关键数据结构，它包含了操作系统对进程进行管理和调度所需的各种信息</u>**。



# 项目基本配置文件

### profile

释义为：**配置文件**、**概要文件**、轮廓、剖面



在计算机领域中，“profile”一词可以有多种含义，具体取决于上下文。以下是一些常见的解释：

- **配置文件**：在软件和系统配置中，"Profile"可以指一组配置设置，这些设置可以应用于不同的环境或条件。例如，在Maven这样的构建工具中，"Profile"允许用户根据不同的环境（如开发环境、测试环境和生产环境）来配置不同的构建参数。

- **用户资料**：在网络服务和应用程序中，"Profile"通常指用户的个人资料，包括用户的信息和设置。

- **性能分析**：在编程和软件开发中，"Profile"或"Profiling"是指分析程序的性能，以识别瓶颈和优化代码的过程。例如，"Memory Profile"或"CPU Profile"是指分析内存使用或CPU使用情况的工具或数据。

- **用户画像**：在数据挖掘和市场营销中，"Profile"可以用来指代根据用户行为和偏好构建的用户画像，帮助提供个性化的服务或内容。
- **程序或系统的概述**：在某些情况下，"Profile"可以用来描述程序或系统的主要特征和功能。

- **安全描述**：在计算机安全领域，"Profile"可以是对一个实体（如用户、系统或服务）的访问控制特性的描述。



### annos

- **注释**：在编程中，"anno"是"**annotation**"的缩写，指的是<u>代码中的注释或元数据</u>，用于提供额外的信息，比如代码的功能说明、参数描述等。
- **标注**：在机器学习和计算机视觉中，特别是在处理图像或视频数据集时，"annos"可能指的是"annotations"，即标注数据。这些标注可以包括物体的边界框、类别标签、跟踪信息等，用于训练和评估目标检测、图像识别等模型。
- **性能分析**：在性能分析中，"anno"可能指的是"annotation"，用于标记代码中特定的部分以进行性能测量，比如在代码中标记热点函数或性能瓶颈区域。
- **配置文件**：在某些软件配置中，"annos"可能指的是配置文件中的注释或特定设置，这些注释或设置用于指导软件的行为或配置环境。



## 输出格式|数据结构

### 结构化输出|结构化数据

也就是可以用 **表** 的形式进行的存储的数据。

以一种**组织化、标准化的方式呈现信息**，使得信息易于理解和处理。

在计算机科学和数据分析中，**结构化数据通常指那些存储在关系型数据库中的数据**，它们具有固定的格式和预定义的模式。结构化输出的例子包括：

- **数据库记录**：例如，一个客户信息数据库可能包含姓名、地址、电话号码和电子邮件等字段，每条记录都遵循相同的格式。
- **电子表格**：Excel表格中的数据通常按照行列格式组织，每列代表一个数据字段，每行代表一个数据记录。
- **`CSV`文件**：逗号分隔值（`CSV`）文件是一种常见的结构化数据格式，数据以纯文本形式存储，字段之间用逗号分隔。
- **`SQL`数据库**：`SQL`（结构化查询语言）数据库如`MySQL`、`PostgreSQL`等，它们存储的数据具有固定的表结构。
- **`API`响应**：许多应用程序编程接口（`API`）返回结构化的`JSON`或`XML`格式数据，这些数据易于机器解析和处理。
- **统计表格**：政府或企业发布的统计数据，通常以表格形式呈现，具有明确的标题和一致的数据格式。
- **时间序列数据**：在金融市场分析中，股票价格、交易量等数据通常以时间序列的形式存储，每条记录包含时间戳和相应的数值。

### 半结构化输出|半结构化数据

典型：字典-键值对。

半结构化数据介于结构化数据和非结构化数据之间。它们具有一定的结构，但不像结构化数据那样严格。半结构化数据通常包含一些**标记**或**分隔符**，**即在不同的位置严格限制了内容**。这些可以帮助识别数据的不同部分。**但数据本身并不遵循严格的模式**。

半结构化数据的例子包括：

- **HTML和XML文档**：这些文档包含标签，但标签内的内容可以是自由格式的。
- **`JSON`**：虽然`JSON`是一种结构化的数据格式，但它比传统的关系型数据库更灵活，可以包含嵌套结构和多种数据类型。
- **电子邮件**：通常包含头部信息（如发件人、收件人、主题）和正文，正文部分可能是自由格式的文本。
- **日志文件**：系统和应用程序生成的日志，通常包含时间戳和一些固定的字段，但日志消息本身可能是非结构化的文本。

### 非结构化输出|非结构化数据

典型：各类型的基础文件实际都是非结构化数据。

非结构化数据是指没有固定格式和模式的数据。这类数据通常不易于直接进行自动化处理和分析，因为它们缺乏统一的结构。

非结构化数据的例子包括：

- **文本文件**：如`TXT`文件、`Word`文档、`PDF`文档等，它们包含自由格式的文本。
- **图片**：`JPEG`、`PNG`等格式的图像文件，它们包含视觉信息。
- **音频和视频**：`MP3`、`MP4`等格式的多媒体文件，包含声音和视频信息。
