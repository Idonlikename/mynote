# 第三章内存管理

## 内存的基础知识

### 计算机内部存储层次

计算机系统的存储器被组织成一个6个层次的金字塔形的层次结构， 如下图：

#### 芯片内

S0层为CPU内部**寄存器**——<u>速度最快但是存储量最小</u>，只有KB级别
S1层为芯片内部的**高速缓存(cache)**内存——L1、L2缓存，速度的分别。

#### 芯片外

S2层为芯片外的**高速缓存**(SRAM、 DRAM、 DDRAM)——存储量更大的缓存。

#### 主存

S3层为主存储器(Flash、PROM、EPROM、 EEPROM)——我们常说的<u>**内存就是主存储器，也就是内存条**</u>

#### 外存

S4层为外部存储器(磁盘、光盘、CF、SD卡)——存储量大可以上至TB但是相应的读取速度慢。
S5层为远程二级存储(分布式文件系统、Web服务器)


![alt text](/image/figure1.png)


在这种存储器分层结构中，**<u>上面一层的存储器作为下一层存储器的高速缓存</u>**。

理解这里的高速缓存：

下一层可以存储更多更大的数据但慢，而上一层的存储器速度更快但小

所以可以把下一层中被用到的内存传输给上一层处理。

所以说上一层是下一层的

例如：

**CPU寄存器**就是**cache**的高速缓存，<u>寄存器保存来自cache的字</u>; 

**cache**又是**内存层**的高速缓存，<u>缓存将从内存中提取数据送给CPU进行处理，并将CPU的处理结果返回到内存中</u>;

**内存**又是**主存储器**的高速缓存，<u>内将经常用到的数据从Flash等主存储器中提取出来，放到内存中，从而加快了CPU的运行效率</u>。

嵌入式系统的主存储器容量是有限的，磁盘、光盘或CF、SD卡等外部存储器用来保存大信息量的数据。在某些带有分布式文件系统的嵌入式网络系统中，外部存储器就作为其他系统中被存储数据的高速缓存。

另一个图：

![img](E:\site\note\docs\Computer\OS\内存管理\image\figure1.png)

如上图所示，**<u>越往上，存储介质的访问速度越快，价格也越高</u>**。其中**寄存器**、**高速缓存**、**主存储器**和**磁盘缓存**均<u>属于存储管理的管辖范畴，**掉电后它们存储的信息不再存在**。</u>

**固定磁盘**和**可移动存储介质**<u>属于设备管理的管辖范畴</u>，它们存储的信息将被长期保存。而<u>磁盘缓存本身并不是一种实际存在的存储介质，它依托于固定磁盘，提供对主存储空间的扩充。</u>

**<u>可执行的程序必须被保存在计算机的主存储器（内存）中</u>**，与外围设备交换的信息一般也依托于主存储器地质空间。由于处理器在执行指令时主存访问时间远大于其他处理时间，寄存器会告诉缓存被引入来加快指令的执行。

**寄存器**是访问速度最快但最昂贵的存储器，它的容量小，一般以字（word）为单位。一个计算机系统可能包括几十个甚至上百个寄存器，用于加速存储访问速度，如：寄存器操作数的使用，或用地质寄存器加快转换速度。

**高速缓存**的容量稍大，其访问速度快于主存储器，利用它存放主存中一些经常访问的信息可以大幅度提高程序执行速度。

由于程序在执行和处理数据时存在着<u>**顺序性**、**局部性**、**循环性**和**排他性**</u>，因此在程序执行时，<u>有时并不需要把程序和数据全部调入内存，而只需先调入一部分，待需要时逐步调入</u>。

这样，计算机系统为了<u>容纳更多的算题树，或是为了处理更大批量的数据，就可以在磁盘上建立**磁盘缓存**</u>以<u>**扩充主存储器的存储空间**</u>。

算题的程序和处理的数据可以装入**磁盘缓存**，操作系统自动实现主存储器和磁盘缓存之间数据的调进调出，从而向用户提供了比实际存储容量大的存储空间。

地址转换与存储保护

<u>**用户编写程序时，是从0地址开始编排用户地址空间的，我们把用户编程时用的地址成为逻辑地址（相对地址）**</u>。

**而当程序运行时**，它将被<u>装入主存储地址空间的某些部分，此时程序和数据的实际地址一般不可能同原来的逻辑地质一致</u>，**<u>我们把程序在内存中的实际地址称为物理地址（绝对地址）</u>**。相应构成了用户编程使用的逻辑地址空间和用户实际运行的物理地址空间。

为了保证程序的正确运行，<u>必须**把程序和数据的逻辑地址转换为物理地址**，这一工作称为**地址转换**或**重定位**</u>。

地址转换有两种方式：

一种方式是在作业**装入时**由作业**装入程序**实现地址转换，称为**静态重定位**；

另一种是在**程序执行时**实现地址转换，称为**动态重定位**。

动态重定位必须借助于硬件的地址转换机构（**定位寄存器**）的实现。

### 思维导图

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure2.png)

### 什么是内存？有何作用？

内存可存放数据。

程序执行前，<u>需要将程序放入内存中才能被CPU所处理</u>----缓和CPU和硬盘之间速度的矛盾。

解释：硬盘的内存存储量大但是读取速度慢，CPU的计算速度很快，很容易导致<u>硬盘的读取速度拖累CPU的处理速度</u>。所以需要内存用来帮助我们存取数据进行处理。（找到一个存储和速度都适宜的介质）

以手机理解内存与外存：8+256  8G是内存  256G是外存

#### （1）存储单元

存储单元是计算机系统中用于存储二进制数据的**最小单元**。我们在学习C语言时**指针所指的地址**正是存储单元。

###### 存储器

主要功能：

存放**程序**和**数据**

两个分类：**主存储器**（主存也就是**内存**，<u>**CPU能够直接访问**</u>）和**辅助存储器**（**外存**，**磁盘硬盘**）

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure3.png)

主存储器组成：

- 每个**存储元件**存储一位二进制代码0/1
- **存储单元**可存储一串二进制代码，称这串**代码为存储字**。称这串代码的**位数为存储字长**，比如我图中所画每个存储单元存储8位的二进制数，存储字长为8。
- 存储字长可以是1B或是字节（byte）的偶数倍，1（**字节，B，byte**）=8bit(**bit**就是**位**，也叫**比特位**)

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure4.png)

**主存储器的工作方式**
系统中有多个程序并发执行，多个程序的数据同时放到内存中。而我们的主存（内存）按照数据**按存储单元的地址进行存取**，以对大量的数据进行区分。这种存取方式称为**按地址存取方式**（**相联存储器按内容访问**）

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure5.png)

#### （2）几个常用数量单位&内存地址

1byte=1B=8bit

2^10^=1024B=1KB

2^20^=1024KB=1MB

2^30^=1024MB=1GB

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure6.png)

### 进程运行的基本原理

#### 指令的工作原理

从x=x+1大致看一下指令的执行过程：

分为三个部分：x = 的**赋值指令**

​						   **提取x的指令**

​						   对x进行+1的**操作指令**

这三种指令的对于计算机而言组成一般是<u>（指定操作行为的**操作码**，存取数据的**目标地址**，取数据的**原地址**）</u>

对于这个指令：

①我们读取第一个指令，即x=x+1中的右边的"x"。这个指令告诉我们这行代码的操作对象是谁。其意味着我们要对x进行**取出计算操作**，所以我们从变量x所在地址取出他的值，将其放到寄存器中。



②我们读取第二条指令，即x=x+1中的"+1"。告诉我们要对寄存器中的x进行**+1的操作**。

​	具体他的指令是：（**操作码**（+），**目标地址**（寄存器的地址），**具体加的数是多少**）



③我们读取第三条指令，即最后的"x="指令。在前面的指令中我们的计算机已经计算完了x的值，现在要采取**赋值操作**。

​	那对于这个指令：（**赋值操作码（"="），目标地址（"="的左边），原地址（"=的右边"）**），将右边的值从寄存器中取出，将其放在"=的左边"的变量上。也就是x原来的位置上。

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure7.png)

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure8.png)![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure9.png)



#### 逻辑地址（相对地址）vs物理地址（绝对地址）

同样指向地址为179的位置。

对于地址为100的位置而言，其**相对位置**为79。

而179为这个位置的**绝对位置**。

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure10.png)

程序经过编译、链接后生成的指令中**指明的是逻辑地址（相对地址）**，即：相对于进程起始地址而言的地址。

在我们编写程序代码时，程序的内存地址是从0地址开始编排用户程序的地址空间的，我们把编程时用的地址称为逻辑地址（相对地址）。而当运行程序时我们则需要把这些**<u>程序中的相对位置转为绝对位置来使我们的程序能够稳定运行</u>**。

#### 从写程序到程序运行—编译、链接、装入

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure11.png)

程序经过**编译**、**链接**处理后，**生成装入模块**，从而**作为进程运行**。

**编译**：通过**编译程序（编译器）**，将用户的源代码编译成若干个目标模块。（**将高级语言翻译为机器语言**）

**链接**：由**链接程序**将编译后的各个目标模块，以及**将所需的函数库链接**在一起，<u>可以理解为组装在一起形成一个完整的**装入模块**</u>。这个装入模块也就是`.exe`文件

**装入**：装入程序将装入模块**装入内存**进行**运行**。

#### 装入模块装入内存

不修改装入模块中的指令地址就直接装入内存的话（若采用了绝对地址装入，可能会对未分配地址的操作而出错）：

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure12.png)![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure13.png)

#### 装入的三种方式

因为确定在进程运行时，会将程序的数据根据相对位置装入，我们没办法知道他确切的装入了哪个地址。所以**<u>如何将相对地址转为正确绝对地址是一个问题</u>**。因而我们延伸出三种装入方式，来帮助我们将装入模块装载在内存中。

这三种装入方式都是为了**<u>解决将指令中的逻辑地址转化为物理地址</u>**。

##### ①绝对装入

绝对装入是在我们的程序尚还**==在编译时==**，<u>**就将程序的逻辑地址改写成正确的绝对地址来进行的装入**</u>。

<u>**灵活度低**，**只适用于单道程序环境**</u>。

补充：**单道程序环境**是指<u>一次只能执行一个程序的计算机环境</u>。在这种环境下，计算机系统一次只能处理一个用户程序，直到该程序执行完毕或者被中断。这种环境通常用于早期的计算机系统，特别是那些没有操作系统支持的系统中。

<u>个人理解：单道程序环境因为只能运行一个程序，所以他装入的初始地址都是定死的，所以可以用绝对装入通用更改。</u>

在单道程序环境下，用户需要等待当前程序执行完毕，才能执行下一个程序。这种环境的特点包括：

1. **顺序执行**：每个程序按照顺序依次执行，直到完成或者被中断。
2. **资源独占**：一旦程序开始执行，它会独占计算机的资源，包括CPU、内存和输入输出设备。
3. **无操作系统支持**：在早期的计算机系统中，可能没有操作系统来管理多个程序的执行，因此只能采用单道程序环境。

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure14.png)



##### ②静态重定位

**静态重定位是指在==<u>装入模块时</u>==，它<u>根据装配模块将==要装入的内存起始位置==，直接修改装配模块中的有关使用地址</u>的指令**。

在静态重定位中，**程序中的地址信息是在<u>==装入时一次完成的==</u>**。装入程序会**<u>根据程序中的地址引用以及装入内存的起始位置，将相对地址修改为实际的物理地址</u>**。

操作系统的装入程序要<u>**把装配模块和重定位项表一起装入内存**</u>。由装配模块的实际装入起始地址得到**重定位因子**，然后实施如下两步：

①**取重定位项（装入内存的起始位置）**，**加上重定位因子**（相对于相对地址的起始位置改变量）而**得到需要修改位置的实际地址**；理解：获取相对于代码默认的位置和实际位置的差值。

②**对实际地址中的内容再做加重定位因子的修改**，从而完成指令代码的修改。对程序内部空间的指令的位置修改。

对所有的重定位项实施上述两步操作后，静态重定位才完成，而后可启动程序执行。使用过的重定位项表内存副本随即被废弃。要求<u>**内存必须连续**</u>，**必须分配程序要求的所有的内存空间**。

**优点**：是**无需增加硬件**地址转换机构，便于实现程序的静态连接。在早期计算机系统中大多采用这种方案。 

**缺点**：内存空间**不能移动**，也**不能再申请内存空间**；各个**用户进程很难共享**内存中同一程序的副本

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure15.png)

##### ③动态重定位

**动态重定位是指，<u>==在程序执行过程中==进行地址重定位</u>。更确切地说，是<u>==在CPU每次访问内存单元前==才进行地址变换</u>。**

动态重定位可使装配模块**不加任何修改**而装入内存。但是它**需要硬件**——**重定位寄存器**的支持。

实际上就是依靠重定位寄存器存当中放入模块的初始的位置。在==运行时==直接运行模块和这个初始位置，来达到通过模块自身的相对位置达到绝对位置的效果。可以理解为没有任何修改，是在运行引用地址的时候自动使用（寄存器+相对地址）

**优点**：1）目标**模块装入内存时无需任何修改**，因而装入之后再搬迁也不会影响其正确执行，这对于**存储器紧缩**、**解决碎片问题**是极其有利的；

​			2）一个程序由若干个相对独立的目标模块组成时，每个目标**模块可以分开装入**一个存储区域，这些**存储区域可以不是顺序相邻的**，只要**各个模块有自己对应的定位寄存器就行**。

**缺点：**需要**硬件支持**。

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure16.png)

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure17.png)![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure18.png)链接的三种方式

##### ① 静态链接

装入之前链接

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure19.png)

##### ②装入时动态链接

边装入边链接

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure20.png)

##### ③运行时动态链接

运行的时候才链接

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure21.png)

## 内存管理管些什么？

### 思维导图

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure22.png)

### 1.[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)空间的分配与回收

操作系统负责内存空间的分配与回收：给进程分配他们运行所需的内存空间，同时当进程完成之后回收这部分内存空间。

**如何最高效地使用有限的内存空间？并且有效回收进程？**

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure23.png)

### 2.内存空间的扩展（实现虚拟性）

**一个程序如果大过我们的内存空间，我们该如何运行呢？**

操作系统通过技术从逻辑上对内存空间进行扩容。（虚拟内存）

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure24.png)

### 3.地址转换（实现进程的运行）

这里说的便是我们之前说的三种重定位方式。绝对装入，静态以及动态。 

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure25.png)

#### 三种装入方式

绝对装入：用于单道程序运行空间

静态重定位：早期操作系统

动态重定位：现代操作系统，硬件支持下。

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure26.png)

### 4.内存保护

内存保护的意义：一个**单独的进程应该只能访问自己占有的内存，而不能访问其他内存**。

如果访问其他内存，很有可能**影响其他进程**的运行，甚至**影响操作系统**。

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure27.png)

#### 内存保护的两种方式

方法一：设置**上下限寄存器**，需要寄存器的**硬件支持**。通过两个寄存器来限制进程能访问内存空间，由CPU来判断是否超过两个寄存器记录的范围，从而判断是否越界。==用寄存器a和b直接给一个上下限==

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure28.png)

方法二：采用之前提及的**重定位寄存器（基址寄存器）**，和一个**界地址寄存器（限长寄存器）**。原理简单，类似于第一种方法。不过采用的是两个寄存器对进程的起始位置和占据内存的长度的记录，二者相加，CPU来判断进程访问的内存是否越界。==采用寄存器a+寄存器b的形式实现上下限==

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure29.png)

## 覆盖技术与交换技术

### 思维导图

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure30.png)

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure31.png)

### 覆盖技术

==前提：运行的进程大于我们内存空间的大小。==

覆盖技术是用于**<u>解决程序内存大小超过内存空间总和</u>**的问题（**<u>运行的程序内存大小，超过了计算机内部的内存空间</u>**），内存自身的关联技术

<u>**是对于模块的操作**</u>

具体方法：

①将程序**分成多个模块**。

②**常用模块**在内存中**保持常驻**。

③**不常用的模块**在需要时**调入内存**。

将内存分为**一个"固定区"**以及**若干个"覆盖区"**。

**常驻的模块放在固定区内**，**而不常用的模块放在覆盖区**，**随时调入和调出**内存。

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure32.png)

以此为例：

A是主程序段需要一直调用，所以其在固定区一直调入而不调出

而BC是两个不同的分区，意味着在使用时另一方停用，所以二者用覆盖区。余下同理。

缺点看底下

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure33.png)

### 交换技术

==前提：内存的空间紧张不够用。==

**<u>是对于进程的操作</u>**

是内存与外存之间的技术。（这种技术在进程较大时也可能耗费大量的时间）

**内存空间紧张时**，将某些进程暂时**换出外存**但是**保留PCB(记录进程放于外存哪个位置可以直接取用）**插入挂起队列，把外存的某些具备运行条件的进程**换入内存**（也就是<u>内存空间不紧张的时候将那些换出内存的进程重新换入</u>）。（进程在内存和磁盘间的动态调度）



在**<u>交换的过程中产生碎片的间隙</u>**称之为：**空洞（hole）**。

要想利用碎片化的区域就要尽可能将进程所在的地址向低地址移动——**内存紧缩（ceremony compaction）**，也就是后续我们会在内部碎片和外部碎片提及的一种技术——**紧凑技术**。



这也正是**中级调度（内存调度）：就是在交换技术当中选择一个处于外存的进程换入内存。**

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure34.png)

- 回忆复习一下进程调度

挂起状态：暂时换出外存等待的进程状态就做挂起状态。

分为：就绪挂起，阻塞挂起。

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure35.png)

#### 第一个问题：进程放在外存的何种位置？

**磁盘空间**会有**对换区**和**文件区**两部分。

①<u>文件区是用来**存储文件**的，所以主要**追求文件空间的利用率**，因而采用**离散分配方式**</u>；

②对换区只占用很小的磁盘空间，被<u>换出的进程就在对换区。由于对换区的进程在使用时**追求高效率的换入换出**，因而采用**连续分配方式**</u>。

总之，**对换区的I/O速度比文件区快**



#### 第二个问题：应该什么时候交换？

交换通常发生在**多个进程运行**且**内存吃紧**时进行，而<u>系统负荷降低就暂停交换</u>。



#### 第三个问题：应该换出哪些进程？

①优先换出**阻塞进程**；

②**优先级较低的进程**；

③为了防止优先级低的进程被调入后又很快调出，还会**考虑进程的驻留时间**



![](E:\site\note\docs\Computer\OS\内存管理\image\figure36.png)



## 内存的分配与回收

### 思维导图

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure37.png)

进程在使用内存的时候，操作系统应该根据进程的大小、内存空间的大小以及进程的优先度等问题进行考虑，在调度上充分利用内存空间大小，做到合理的分配与和对完成进程的及时回收。

### 连续分配管理方式

一般所有的分配都会把内存被分为了**系统区**和**用户区**。

<u>系统区就是用于存放**操作系统进程**的相关数据</u>，而<u>用户区存放**用户进程**的相关数据</u>。



#### 1.单一连续分配

在单一连续分配中内存中**只能有一道用户程序**，**<u>用户程序独占整个用户区空间</u>**，相当于分配了整个内存空间供给一个进程。



**优点**：易于实现；**无外部碎片**；可以**采用覆盖技术扩充内存**；**不一定需要采用内存保护**。

**缺点**：**不支持多道任务并发运行**；**有内部碎片**；**存储器利用率极低**。



补充：

内部碎片：分配给程序的内存空间中，有**部分空间进程是没有使用（分配内存>进程大小）**的，造成了内存空间的浪费，这就是内部碎片。大白话：分配内存大于进程所需内存。

外部碎片：内存中存在的一些**不连续的、无法被利用的小块空闲内存**。大白话：内存空间中没分配进程，且太小无法分配进程的内存。

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure38.png)

#### 2.固定分区分配

在固定分区分配中其中用户区**按照<u>一定的内存大小对内存进行划分（分区大小可以相等，也可以不相等）</u>**，**划分成了若干个固定大小的分区**，<u>**每个分区只能装入一个进程**</u>。

<u>对于分区大小**相同**</u>的固定分区分配：

**优点**：可以控制多个相同对象

**缺点**：缺乏灵活性



<u>对于分区大小**不等**</u>的固定分区分配

**相较于分区大小相等**，**增加了灵活性**，满足**不同大小进程需求**。

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure39.png)

##### （1）分区说明表

对于固定分区分配而言，内存中很有可能有大量的分区。我们的系统需要知道每个分区对应的进程、大小、地址。所以我们需要一个**分区说明表**的**数据结构**，来帮助我们进行管理。

也有的采用**<u>位图</u>（一种数据结构）**的方式进行管理，把内存分为单位小区域标注上0/1来表明是否空闲。扫描连续为0能满足进程大小的区域给进程分配内存，因为数量多比较耗时，不如链表或者说明表。

每个表项：<u>包含对应**分区**的**大小**、**起始地址**、**状态**</u>

操作系统可以通过分区说明表了解分区的使用情况，在有新进程的时候找到合适大小且未分配的分区给其分配内存。



![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure40.png)



对于固定分区分配：

优点：实现简单；**无外部碎片**

缺点：**会产生内部碎片**；如果**程序太大，大过了每个分区**，会**使用覆盖技术，而降低了计算机的性能**。



#### 3.动态分区分配（可变分区分配）

**为了解决上述两种分配都会产生内部碎片降低内存利用率的问题（分配内存>进程内存）**，进而衍生出了动态分区分配。

**<u>动态分区分配==可变分区分配</u>**。<u>**在进程装入内存时**</u>，<u>**根据进程的大小动态建立分区**</u>。

因为是完全按照进程分配的内存，所以**没有内部碎片**，但也因此会**导致内存空间的<u>内存分布出现不连续</u>^1^或者<u>内存空间很小</u>^2^的情况，即<u>出现外部碎片</u>**。

^1^的情况出现在某个<u>进程运行完毕而其上下进程仍在运行，出现了内存分布不连续</u>。

^2^的情况出现在内存空间<u>都按照进程分配后</u>，最后<u>剩余内存=内存空间-总进程占据空间</u>。导致会出现剩余空间出现内存空间很小的情况。



![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure41.png)

##### 内存分区分配问题的重要性：

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure42.png)![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure43.png)第一个问题：系统要用怎样的数据结构记录内存的使用情况呢？

采用两种数据结构：①空闲分区表 ②空闲分区链

空闲分区表：每一个空闲分区对应一个空闲表项。包括分区号、分区大小、起始地址、状态等信息

空闲分区链：每个分区的都起始部分以及末尾部分都设置指针（**双向链表**），分别指向前一个空闲分区和后一个空闲分区。关于**分区的信息一般统一放在起始部分里**。



![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure44.png)

###### 第二个问题：当多个空闲分区都能满足要求时，应该选择哪个分区进行分配？

把一个新作业放入内存时，<u>按照一定的**动态分区分配算法**进行分配</u>。

**动态分区分配算法**：<u>**按照一定的规则（算法）从空闲分区表或者空闲分区链中选出一个合适的分区分配给该作业**</u>。

因为动态分区分配算法对系统性能有很大的影响，因此进行了广泛的研究。见下一节。

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure45.png)

###### 第三个问题：如何进行分区的分配和回收操作？

###### 如何分配？

以空闲分区表为例：

若一个进程申请4MB的空间大小，而此时内存空间分的分布如下图：

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure46.png)

第一种情况：假设我们采用某种算法算法，从这20MB里分配4MB给这个进程。则后续我们需要对这个空闲分区表进行相应的处理。

将此例中为将表中的空闲分区大小-4MB，并更改其起始地址。因为我们分配的空间是远大于进程申请的，所以略作更改即可。

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure47.png)

第二种情况：若按照某种算法，我们将恰为4MB的分区分给了他。

显然，我们需要删除这个空闲分区表中的对应表项。如果是空闲分区链的话我们需要删除对应结点，并要更改前后结点的指针。

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure48.png)

###### 如何回收？

如果说一个进程运行结束了。那么我们有两种处理方式：

①如果结束的进程有相邻的空闲内存分区，那么我们直接将他并入此空闲内存当中，仅需要**①修改此分区的大小（在尾）**或者**②修改大小和起始地址（在首）**。若**③上下都有相邻的空闲分区，则三者皆合并（在中）**。

②若结束的进程为一个独立的空闲分区的话，那我们需要**添加一个表项，而链则需要增添一个节点**。



②情况中的需要修改大小和起始位置的情况：

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure49.png)

①情况中仅需要修改分区大小的情况：

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure50.png)

③情况中上下都有空闲一并合并的情况：

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure51.png)

第二类情况中新添一个表项的情况

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure52.png)

#### 4.内部碎片与外部碎片

前面解释过了，这里再解释一遍

内部碎片：分配给某些进程的内存超出了作业本身需要的内存，这部分多出来的内存即为外部碎片。

外部碎片：内存空间中因为太小（宏观上说太零散，太小）无法利用的空闲内存分区



可以依靠**<u>==紧凑技术（内存紧凑，ceremony compaction）==来解决==外部碎片==问题</u>**：也就是零碎的空闲内存分区是足够进程运行的，我们通过紧凑是零碎的内存拼凑起来分配给进程。也就是**<u>通过将已经分配内存的进程进行移位来达到内存空闲分区连续进而足够大可供使用的目的</u>**。

（采用的是**动态重定位**，通过**改变寄存器的存储的起始地址数据**，轻松达到**移动进程的目的**）。

注意：即使采用的是更改寄存器存储的方式，但是1G的进程移动仍需要5s并非最好的方式。



![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure53.png)![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure54.png)

## 动态内存分配四中算法

### 思维导图

- 本篇文章是对上一篇文章内存的分配与回收提到的`动态分区分配算法`的补充

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure55.png)

### 1.首次适应算法

**<u>从低地址开始查找，找到第一个能够满足大小的空闲分区。</u>**

实现：**<u>空闲内存以地址为排序条件，进行递增次序排序</u>**。每次分配时**<u>按照顺序查找空闲分区表/链</u>**。找到第一个满足要求的空闲分区。

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure56.png)
![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure57.png)
![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure58.png)

### 2.最佳适应算法

**<u>从按照容量大小由小到大排序的表/链中，找到第一个符合条件的空闲分区</u>**

实现：空闲分区按**<u>照容量递增次序链接</u>**。每次分配时**<u>顺序查找空闲分区链/表</u>**，找到**<u>第一个满足要求的分区</u>**。

**缺点**：每次都选最小的，但会留下很多难以利用的内存块。产生**大量外部碎片**

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure59.png)
![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure60.png)
![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure61.png)

### 3.最坏（大）适应算法

为了解决**最佳适应算法**中产生大量外部碎片的问题。每次**分配时优先使用最大的连续空闲分区**，这样剩余空闲区不会太小，更方便使用。

思想：**<u>从按照容量大小由大到小排序的表/链中，找到第一个符合条件的空闲分区</u>**

缺点：容易导致**无法为大进程分配**内存空间。

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure62.png)
![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure63.png)
![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure64.png)
![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure65.png)

### 4.邻近适应算法

使用首次适应算法的时候，每次都从链头查找。导致①低地址部分出现大量的很小的空闲分区。②每次遍历的开销成本大。因而使用邻近适应算法，均摊了这种外部碎片的集中，并且避免了遍历的开销。

优点：算法开销小，空闲分区不会集中。缺点是高地址的大分区会被用完。

思想：从上一次分配的地址之后开始找。

实现：空闲分区**按照地址递增排序**。每次分配内存**从上次查找结束的位置开始查找空闲分区**，找到第一个满足要求的分区。

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure66.png)
![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure67.png)
![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure68.png)
![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure69.png)
![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure70.png)

### 5.四种算法归纳比较

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure71.png)

## 分页存储-非连续分配管理

非连续分配管理方式：①基本分页存储管理	②基本分段存储管理	③段页式存储管理

### 分页存储

将**==内存空间==**分为一个个相等的分区。<u>每一个分区</u>称之为<u>**页框（页框=页帧=内存块=物理块=物理页面）**</u>。每一个页框有一个编号，称之为**<u>”页框号“（页框号=页帧号=内存块号=物理块号=物理页号）</u>**，页框号如同数组，从0开始。

将**==进程的逻辑地址空间==**也分为与页框大小相等的一个个部分。每个部分称之为“页”或“页面”。每个页面也有编号，“页号”，页号也是从0开始的。（也就是在程序运行那里提及的，**将进程分为一个个指令，每个指令称为页/页面**）

区分：页框，是内存在物理上被划分一个一个的部分。

​			页/页面是进程在逻辑上被划分的一个一个的部分。

操作系统以页框为单位，为各个进程分配内存空间。进程的每一个页面分别放入一个内框中，意味着，**内存的页框和进程页面有一一对应的关系**。



各个页面可以放在不相连的页框中，即可以离散存储。



![image-20231115182202936](E:\site\note\docs\Computer\OS\内存管理\image\figure72.png)

#### 1.为什么学习分页存储？

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure73.png)

#### 2.基本分页存储管理的思想

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure74.png)

#### 3.分页存储管理的重要概念

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure75.png)

#### 4.如何实现地址的转换

在连续分配的时候，我们可以依托寄存器的**偏移量**来进行转换，而在离散的分页中如何转化呢？

特点：虽然进程的各个页面时离散的，但是页面内部还是保持连续的。

对于逻辑地址A：

①确定逻辑地址A的对应页号 P

②通过查页表找到P号页面的起始位置

③确定逻辑地址A的**页内偏移量W**

逻辑地址A的物理地址=P页面中的起始地址+页内偏移量W



![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure76.png)

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure77.png)

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure78.png)

##### 如何确定一个逻辑地址对应的页号，页内偏移量？

①题目会告诉我们，页面的大小（也就是长度），以及所要求的逻辑地址。

<u>**页号=逻辑地址/页面长度（向下取整数）**</u>

<u>**页内偏移量=逻辑地址%页面长度（取余数部分）**</u>

**例如**：

页面大小为50，求逻辑地址40的页号以及页内偏移量

页号=40/50 = 0

页内偏移量=40%50=40    所以P=0，W=40

②采用2进制方法计算：

为了方便计算，页号和页内偏移量一般都为2的整数幂次

这样是因为在计算的时候。

页面大小为2^n^时，那对于一个用二进制表示的逻辑地址而言。**后n位都为偏移量**，而**后n位前的数据表示的是页号**。

很好理解不做解释。



![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure79.png)

##### 为什么页面大小一般设为2的整数次幂？

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure80.png)

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure81.png)

#### 分页存储的逻辑结构

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure82.png)

### 页表

如何知道页面在内存中的起始地址？

这里**引入一个新的数据结构**：**页表**

之前所说，页和页框具有一一对应的关系。我们**借助页表记录**他们之间一一对应的关系。

首先我们需要知道：<u>操作系统会给每个进程建立一张页表，页表通常存在于PCB（进程控制模块）中</u>

进程的逻辑地址空间被分为一个个页面，每一个页面会对应页表中的一个页表项

#### 页面和页表的关系：

一个**进程**对应一张**页表**

进程的**每一个页面**对用**一个页表项**

每个<u>**页表项**由**“页号”**和**“块号”**</u>组成

**==页表==记录==进程页面==**和实际存放的**==内存块（页框）==**之间的对应关系

每个页表的长度实现相同的，页号是“隐含”的

也就是进程有一张页表，进程中的逻辑地址空间被分为若干个页面，每一个==**页面**==都有一个一一对应**==对应的页表项==**。页面号=页号，==每一个页号又对应一个块号==，这个块号指向内存中的物理地址（也就是找到对应的内存块，页框）。从而帮助页面找到对应的页框。

更简单点：**<u>页表中页号存储页面号，而块号存储页框号。从而帮助其一一对应</u>**。

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure83.png)

隐含的解释：

页号并不占据内存，那我们如何得到页号呢？或者如何通过页号找到对应的页表项呢？

因为**<u>页表中，各页表项是按照顺序连续地放置于内存中</u>**。所以知道了页表存放的**起始位置**，以及**页表项的长度（所占字节长度）**，就可以知道对应的页号。

**<u>i号页表项的存放地址=X起始地址+页表项长度*i</u>**



![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure84.png)

## 分页存储管理的基本地址变换结构

### 1.[页表](https://so.csdn.net/so/search?q=页表&spm=1001.2101.3001.7020)寄存器

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure85.png)

#### 地址变换过程

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure86.png)

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure87.png)
![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure88.png)
**一道例题加深印象：**
![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure89.png)

### 2.对页表项大小的进一步讨论

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure90.png)

## 块表地址变换结构

### 1.局部性原理引入快表机制

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure91.png)

### 2.快表（TLB）

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200505111455765.png)

#### 一个例图了解基于快表的地址变换结构

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure92.png)
**引入快表后，地址变换的过程的文字描述：**
![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure93.png)

### 3.基本地址变换与快表地址变换的比较

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure94.png)

## 二级页表原理以及地址结构

### 1.为什么引入二级页表？

因为单级页表存在一些问题，所以引入二级页表和多级页表，有两个问题：

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure95.png)

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure96.png)

上面提到了这两个问题，那么总结一下，并提出解决思想，引入二级页表的概念。

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure97.png)

### 2.二级页表的原理和地址结构

#### 对页表再次分组

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure98.png)

#### 二级页表的地址结构及对应关系

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figure99.png)

### 3.如何实现二级页表的地址变换？

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figurea1.png)

上面的部分我们解决了问题一，接下来是问题二，这里简单叙述一下，后面的文章会继续深入剖析。

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figurea2.png)

### 4.几个小细节

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figurea3.png)

## 基本分段存储管理（段表、地址变换、信息共享）

### 1.什么是分段？

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figurea4.png)

#### 分段的[逻辑地址](https://so.csdn.net/so/search?q=逻辑地址&spm=1001.2101.3001.7020)结构

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figurea5.png)

### 2.段表

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figurea6.png)

### 3.地址变换

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figurea7.png)

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figurea8.png)

### 4.分段、分页管理的对比

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figurea9.png)
![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figurea10.png)

#### 分段实现信息共享共享

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figurea11.png)

#### 为什么分页不方便实现信息共享和保护？

![在这里插入图片描述](E:\site\note\docs\Computer\OS\内存管理\image\figurea12.png)